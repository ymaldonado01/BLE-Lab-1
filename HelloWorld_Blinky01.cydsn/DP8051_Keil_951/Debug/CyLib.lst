C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE CYLIB
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Debug\CyLib.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\3.1\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -.\Generated_Source\PSoC3\CyLib.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,.\Generated_Source\PSoC3) FF(3) DB WL(2) PR(
                    -.\DP8051_Keil_951\Debug/CyLib.lst) OT(0) OJ(.\DP8051_Keil_951\Debug\CyLib.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: CyLib.c
   3          * Version 4.20
   4          *
   5          *  Description:
   6          *   Provides a system API for the clocking, interrupts and watchdog timer.
   7          *
   8          *  Note:
   9          *   Documentation of the API's in this file is located in the
  10          *   System Reference Guide provided with PSoC Creator.
  11          *
  12          ********************************************************************************
  13          * Copyright 2008-2014, Cypress Semiconductor Corporation.  All rights reserved.
  14          * You may use this file only in accordance with the license, terms, conditions,
  15          * disclaimers, and limitations in the end user license agreement accompanying
  16          * the software package with which this file was provided.
  17          *******************************************************************************/
  18          
  19          #include "CyLib.h"
  20          
  21          
  22          /*******************************************************************************
  23          * The CyResetStatus variable is used to obtain value of RESET_SR0 register after
  24          * a device reset. It is set from initialize_psoc() at the early initialization
  25          * stage. In case of IAR EW IDE, initialize_psoc() is executed before the data
  26          * sections are initialized. To avoid zeroing, CyResetStatus should be placed
  27          * to the .noinit section.
  28          *******************************************************************************/
  29          CY_NOINIT uint8 CYXDATA CyResetStatus;
  30          
  31          
  32          /* Variable Vdda */
  33          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  uint8 CyScPumpEnabled = (uint8)(CYDEV_VDDA_MV < 2700);
              
              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
  38          
  39          
  40          /* Do not use these definitions directly in your application */
  41          uint32 cydelay_freq_hz  = BCLK__BUS_CLK__HZ;
  42          uint32 cydelay_freq_khz = (BCLK__BUS_CLK__HZ + 999u) / 1000u;
  43          uint8  cydelay_freq_mhz = (uint8)((BCLK__BUS_CLK__HZ + 999999u) / 1000000u);
  44          uint32 cydelay_32k_ms   = 32768u * ((BCLK__BUS_CLK__HZ + 999u) / 1000u);
  45          
  46          
  47          /* Function Prototypes */
  48          static uint8 CyUSB_PowerOnCheck(void)  ;
  49          static void CyIMO_SetTrimValue(uint8 freq) ;
  50          static void CyBusClk_Internal_SetDivider(uint16 divider);
  51          
  52          #if(CY_PSOC5)
                      static cySysTickCallback CySysTickCallbacks[CY_SYS_SYST_NUM_OF_CALLBACKS];
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 2   

                  static void CySysTickServiceCallbacks(void);
                  uint32 CySysTickInitVar = 0u;
              #endif  /* (CY_PSOC5) */
  57          
  58          
  59          /*******************************************************************************
  60          * Function Name: CyPLL_OUT_Start
  61          ********************************************************************************
  62          *
  63          * Summary:
  64          *   Enables the PLL.  Optionally waits for it to become stable.
  65          *   Waits at least 250 us or until it is detected that the PLL is stable.
  66          *
  67          * Parameters:
  68          *   wait:
  69          *    0: Return immediately after configuration
  70          *    1: Wait for PLL lock or timeout.
  71          *
  72          * Return:
  73          *   Status
  74          *    CYRET_SUCCESS - Completed successfully
  75          *    CYRET_TIMEOUT - Timeout occurred without detecting a stable clock.
  76          *     If the input source of the clock is jittery, then the lock indication
  77          *     may not occur.  However, after the timeout has expired the generated PLL
  78          *     clock can still be used.
  79          *
  80          * Side Effects:
  81          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
  82          *  Any other use of the Fast Time Wheel will be stopped during the period of
  83          *  this function and then restored. This function also uses the 100 KHz ILO.
  84          *  If not enabled, this function will enable the 100 KHz ILO for the period of
  85          *  this function.
  86          *
  87          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
  88          *  Once Per Second interrupt may be made by interrupt routines during the period
  89          *  of this function execution. The current operation of the ILO, Central Time
  90          *  Wheel and Once Per Second interrupt are maintained during the operation of
  91          *  this function provided the reading of the Power Manager Interrupt Status
  92          *  Register is only done using the CyPmReadStatus() function.
  93          *
  94          *******************************************************************************/
  95          cystatus CyPLL_OUT_Start(uint8 wait) 
  96          {
  97   1          cystatus status = CYRET_SUCCESS;
  98   1      
  99   1          uint8 iloEnableState;
 100   1          uint8 pmTwCfg0State;
 101   1          uint8 pmTwCfg2State;
 102   1      
 103   1      
 104   1          /* Enables PLL circuit  */
 105   1          CY_CLK_PLL_CFG0_REG |= CY_CLK_PLL_ENABLE;
 106   1      
 107   1          if(wait != 0u)
 108   1          {
 109   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
 110   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 111   2              pmTwCfg0State = CY_LIB_PM_TW_CFG0_REG;
 112   2              pmTwCfg2State = CY_LIB_PM_TW_CFG2_REG;
 113   2      
 114   2              CyPmFtwSetInterval(CY_CLK_PLL_FTW_INTERVAL);
 115   2      
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 3   

 116   2              status = CYRET_TIMEOUT;
 117   2      
 118   2              while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 119   2              {
 120   3                  /* Wait for interrupt status */
 121   3                  if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 122   3                  {
 123   4                      if(0u != (CY_CLK_PLL_SR_REG & CY_CLK_PLL_LOCK_STATUS))
 124   4                      {
 125   5                          status = CYRET_SUCCESS;
 126   5                          break;
 127   5                      }
 128   4                  }
 129   3              }
 130   2      
 131   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
 132   2              if(0u == iloEnableState)
 133   2              {
 134   3                  CyILO_Stop100K();
 135   3              }
 136   2      
 137   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0State;
 138   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2State;
 139   2          }
 140   1      
 141   1          return(status);
 142   1      }
 143          
 144          
 145          /*******************************************************************************
 146          * Function Name: CyPLL_OUT_Stop
 147          ********************************************************************************
 148          *
 149          * Summary:
 150          *  Disables the PLL.
 151          *
 152          * Parameters:
 153          *  None
 154          *
 155          * Return:
 156          *  None
 157          *
 158          *******************************************************************************/
 159          void CyPLL_OUT_Stop(void) 
 160          {
 161   1          CY_CLK_PLL_CFG0_REG &= ((uint8)(~CY_CLK_PLL_ENABLE));
 162   1      }
 163          
 164          
 165          /*******************************************************************************
 166          * Function Name: CyPLL_OUT_SetPQ
 167          ********************************************************************************
 168          *
 169          * Summary:
 170          *  Sets the P and Q dividers and the charge pump current.
 171          *  The Frequency Out will be P/Q * Frequency In.
 172          *  The PLL must be disabled before calling this function.
 173          *
 174          * Parameters:
 175          *  uint8 pDiv:
 176          *   Valid range [8 - 255].
 177          *
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 4   

 178          *  uint8 qDiv:
 179          *   Valid range [1 - 16]. Input Frequency / Q must be in range of 1 to 3 MHz.
 180          
 181          *  uint8 current:
 182          *   Valid range [1 - 7]. Charge pump current in uA. Refer to the device TRM and
 183          *   datasheet for more information.
 184          *
 185          * Return:
 186          *  None
 187          *
 188          * Side Effects:
 189          *  If this function execution results in the CPU clock frequency increasing,
 190          *  then the number of clock cycles the cache will wait before it samples data
 191          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 192          *  with an appropriate parameter. It can be optionally called if the CPU clock
 193          *  frequency is lowered in order to improve the CPU performance.
 194          *  See CyFlash_SetWaitCycles() description for more information.
 195          *
 196          *******************************************************************************/
 197          void CyPLL_OUT_SetPQ(uint8 pDiv, uint8 qDiv, uint8 current) 
 198          {
 199   1          /* Halt CPU in debug mode if PLL is enabled */
 200   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 201   1      
 202   1          if((pDiv    >= CY_CLK_PLL_MIN_P_VALUE  ) &&
 203   1             (qDiv    <= CY_CLK_PLL_MAX_Q_VALUE  ) && (qDiv    >= CY_CLK_PLL_MIN_Q_VALUE  ) &&
 204   1             (current >= CY_CLK_PLL_MIN_CUR_VALUE) && (current <= CY_CLK_PLL_MAX_CUR_VALUE))
 205   1          {
 206   2              /* Set new values */
 207   2              CY_CLK_PLL_P_REG = pDiv;
 208   2              CY_CLK_PLL_Q_REG = ((uint8)(qDiv - 1u));
 209   2              CY_CLK_PLL_CFG1_REG = (CY_CLK_PLL_CFG1_REG & CY_CLK_PLL_CURRENT_MASK) |
 210   2                                      ((uint8)(((uint8)(current - 1u)) << CY_CLK_PLL_CURRENT_POSITION));
 211   2          }
 212   1          else
 213   1          {
 214   2              /***********************************************************************
 215   2              * Halt CPU in debug mode if:
 216   2              * - P divider is less than required
 217   2              * - Q divider is out of range
 218   2              * - pump current is out of range
 219   2              ***********************************************************************/
 220   2              CYASSERT(0u != 0u);
 221   2          }
 222   1      
 223   1      }
 224          
 225          
 226          /*******************************************************************************
 227          * Function Name: CyPLL_OUT_SetSource
 228          ********************************************************************************
 229          *
 230          * Summary:
 231          *  Sets the input clock source to the PLL. The PLL must be disabled before
 232          *  calling this function.
 233          *
 234          * Parameters:
 235          *   source: One of the three available PLL clock sources
 236          *    CY_PLL_SOURCE_IMO  :   IMO
 237          *    CY_PLL_SOURCE_XTAL :   MHz Crystal
 238          *    CY_PLL_SOURCE_DSI  :   DSI
 239          *
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 5   

 240          * Return:
 241          *  None
 242          *
 243          * Side Effects:
 244          *  If this function execution results in the CPU clock frequency increasing,
 245          *  then the number of clock cycles the cache will wait before it samples data
 246          *  coming back from the3 Flash must be adjusted by calling CyFlash_SetWaitCycles()
 247          *  with an appropriate parameter. It can be optionally called if the CPU clock
 248          *  frequency is lowered in order to improve the CPU performance.
 249          *  See CyFlash_SetWaitCycles() description for more information.
 250          *
 251          *******************************************************************************/
 252          void CyPLL_OUT_SetSource(uint8 source) 
 253          {
 254   1          /* Halt CPU in debug mode if PLL is enabled */
 255   1          CYASSERT(0u == (CY_CLK_PLL_CFG0_REG & CY_CLK_PLL_ENABLE));
 256   1      
 257   1          switch(source)
 258   1          {
 259   2              case CY_PLL_SOURCE_IMO:
 260   2              case CY_PLL_SOURCE_XTAL:
 261   2              case CY_PLL_SOURCE_DSI:
 262   2                  CY_LIB_CLKDIST_CR_REG = ((CY_LIB_CLKDIST_CR_REG & CY_LIB_CLKDIST_CR_PLL_SCR_MASK) | source);
 263   2              break;
 264   2      
 265   2              default:
 266   2                  CYASSERT(0u != 0u);
 267   2              break;
 268   2          }
 269   1      }
 270          
 271          
 272          /*******************************************************************************
 273          * Function Name: CyIMO_Start
 274          ********************************************************************************
 275          *
 276          * Summary:
 277          *  Enables the IMO. Optionally waits at least 6 us for it to settle.
 278          *
 279          * Parameters:
 280          *  uint8 wait:
 281          *   0: Return immediately after configuration
 282          *   1: Wait for at least 6 us for the IMO to settle.
 283          *
 284          * Return:
 285          *  None
 286          *
 287          * Side Effects:
 288          *  If wait is enabled: This function uses the Fast Time Wheel to time the wait.
 289          *  Any other use of the Fast Time Wheel will be stopped during the period of
 290          *  this function and then restored. This function also uses the 100 KHz ILO.
 291          *  If not enabled, this function will enable the 100 KHz ILO for the period of
 292          *  this function.
 293          *
 294          *  No changes to the setup of the ILO, Fast Time Wheel, Central Time Wheel or
 295          *  Once Per Second interrupt may be made by interrupt routines during the period
 296          *  of this function execution. The current operation of the ILO, Central Time
 297          *  Wheel and Once Per Second interrupt are maintained during the operation of
 298          *  this function provided the reading of the Power Manager Interrupt Status
 299          *  Register is only done using the CyPmReadStatus() function.
 300          *
 301          *******************************************************************************/
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 6   

 302          void CyIMO_Start(uint8 wait) 
 303          {
 304   1          uint8 pmFtwCfg2Reg;
 305   1          uint8 pmFtwCfg0Reg;
 306   1          uint8 ilo100KhzEnable;
 307   1      
 308   1      
 309   1          CY_LIB_PM_ACT_CFG0_REG  |= CY_LIB_PM_ACT_CFG0_IMO_EN;
 310   1          CY_LIB_PM_STBY_CFG0_REG |= CY_LIB_PM_STBY_CFG0_IMO_EN;
 311   1      
 312   1          if(0u != wait)
 313   1          {
 314   2              /* Need to turn on 100KHz ILO if it happens to not already be running.*/
 315   2              ilo100KhzEnable = CY_LIB_SLOWCLK_ILO_CR0_REG & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
 316   2              pmFtwCfg0Reg = CY_LIB_PM_TW_CFG0_REG;
 317   2              pmFtwCfg2Reg = CY_LIB_PM_TW_CFG2_REG;
 318   2      
 319   2              CyPmFtwSetInterval(CY_LIB_CLK_IMO_FTW_TIMEOUT);
 320   2      
 321   2              while (0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
 322   2              {
 323   3                  /* Wait for interrupt status */
 324   3              }
 325   2      
 326   2              if(0u == ilo100KhzEnable)
 327   2              {
 328   3                  CyILO_Stop100K();
 329   3              }
 330   2      
 331   2              CY_LIB_PM_TW_CFG0_REG = pmFtwCfg0Reg;
 332   2              CY_LIB_PM_TW_CFG2_REG = pmFtwCfg2Reg;
 333   2          }
 334   1      }
 335          
 336          
 337          /*******************************************************************************
 338          * Function Name: CyIMO_Stop
 339          ********************************************************************************
 340          *
 341          * Summary:
 342          *   Disables the IMO.
 343          *
 344          * Parameters:
 345          *  None
 346          *
 347          * Return:
 348          *  None
 349          *
 350          *******************************************************************************/
 351          void CyIMO_Stop(void) 
 352          {
 353   1          CY_LIB_PM_ACT_CFG0_REG  &= ((uint8) (~CY_LIB_PM_ACT_CFG0_IMO_EN));
 354   1          CY_LIB_PM_STBY_CFG0_REG &= ((uint8) (~CY_LIB_PM_STBY_CFG0_IMO_EN));
 355   1      }
 356          
 357          
 358          /*******************************************************************************
 359          * Function Name: CyUSB_PowerOnCheck
 360          ********************************************************************************
 361          *
 362          * Summary:
 363          *  Returns the USB power status value. A private function to cy_boot.
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 7   

 364          *
 365          * Parameters:
 366          *   None
 367          *
 368          * Return:
 369          *   uint8: one if the USB is enabled, 0 if not enabled.
 370          *
 371          *******************************************************************************/
 372          static uint8 CyUSB_PowerOnCheck(void)  
 373          {
 374   1          uint8 poweredOn = 0u;
 375   1      
 376   1          /* Check whether device is in Active or AltActiv and if USB is powered on */
 377   1          if((((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ACTIVE ) &&
 378   1             (0u != (CY_LIB_PM_ACT_CFG5_REG & CY_ACT_USB_ENABLED     )))  ||
 379   1             (((CY_PM_MODE_CSR_REG & CY_PM_MODE_CSR_MASK) == CY_PM_MODE_CSR_ALT_ACT) &&
 380   1             (0u != (CY_LIB_PM_STBY_CFG5_REG & CY_ALT_ACT_USB_ENABLED))))
 381   1          {
 382   2              poweredOn = 1u;
 383   2          }
 384   1      
 385   1          return (poweredOn);
 386   1      }
 387          
 388          
 389          /*******************************************************************************
 390          * Function Name: CyIMO_SetTrimValue
 391          ********************************************************************************
 392          *
 393          * Summary:
 394          *  Sets the IMO factory trim values.
 395          *
 396          * Parameters:
 397          *  uint8 freq - frequency for which trims must be set
 398          *
 399          * Return:
 400          *  None
 401          *
 402          *******************************************************************************/
 403          static void CyIMO_SetTrimValue(uint8 freq) 
 404          {
 405   1          uint8 usbPowerOn = CyUSB_PowerOnCheck();
 406   1      
 407   1          /* If USB is powered */
 408   1          if(usbPowerOn == 1u)
 409   1          {
 410   2              /* Unlock USB write */
 411   2              CY_LIB_USB_CR1_REG &= ((uint8)(~CY_LIB_USB_CLK_EN));
 412   2          }
 413   1          switch(freq)
 414   1          {
 415   2          case CY_IMO_FREQ_3MHZ:
 416   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_3MHZ_PTR);
 417   2              break;
 418   2      
 419   2          case CY_IMO_FREQ_6MHZ:
 420   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_6MHZ_PTR);
 421   2              break;
 422   2      
 423   2          case CY_IMO_FREQ_12MHZ:
 424   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_12MHZ_PTR);
 425   2              break;
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 8   

 426   2      
 427   2          case CY_IMO_FREQ_24MHZ:
 428   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_24MHZ_PTR);
 429   2              break;
 430   2      
 431   2          case CY_IMO_FREQ_48MHZ:
 432   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_TR1_PTR);
 433   2              break;
 434   2      
 435   2          case CY_IMO_FREQ_62MHZ:
 436   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_67MHZ_PTR);
 437   2              break;
 438   2      
 439   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_80MHZ_PTR);
                      break;
              #endif  /* (CY_PSOC5) */
 444   2      
 445   2          case CY_IMO_FREQ_USB:
 446   2              CY_LIB_IMO_TR1_REG = CY_GET_XTND_REG8(CY_LIB_TRIM_IMO_USB_PTR);
 447   2      
 448   2              /* If USB is powered */
 449   2              if(usbPowerOn == 1u)
 450   2              {
 451   3                  /* Lock USB Oscillator */
 452   3                  CY_LIB_USB_CR1_REG |= CY_LIB_USB_CLK_EN;
 453   3              }
 454   2              break;
 455   2      
 456   2          default:
 457   2                  CYASSERT(0u != 0u);
 458   2              break;
 459   2          }
 460   1      
 461   1      }
 462          
 463          
 464          /*******************************************************************************
 465          * Function Name: CyIMO_SetFreq
 466          ********************************************************************************
 467          *
 468          * Summary:
 469          *  Sets the frequency of the IMO. Changes may be made while the IMO is running.
 470          *
 471          * Parameters:
 472          *  freq: Frequency of IMO operation
 473          *       CY_IMO_FREQ_3MHZ  to set  3   MHz
 474          *       CY_IMO_FREQ_6MHZ  to set  6   MHz
 475          *       CY_IMO_FREQ_12MHZ to set 12   MHz
 476          *       CY_IMO_FREQ_24MHZ to set 24   MHz
 477          *       CY_IMO_FREQ_48MHZ to set 48   MHz
 478          *       CY_IMO_FREQ_62MHZ to set 62.6 MHz
 479          *       CY_IMO_FREQ_74MHZ to set 74.7 MHz (not applicable for PSoC 3)
 480          *       CY_IMO_FREQ_USB   to set 24   MHz (Trimmed for USB operation)
 481          *
 482          * Return:
 483          *  None
 484          *
 485          * Side Effects:
 486          *  If this function execution results in the CPU clock frequency increasing,
 487          *  then the number of clock cycles the cache will wait before it samples data
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 9   

 488          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 489          *  with an appropriate parameter. It can be optionally called if the CPU clock
 490          *  frequency is lowered in order to improve the CPU performance.
 491          *  See CyFlash_SetWaitCycles() description for more information.
 492          *
 493          *  When the USB setting is chosen, the USB clock locking circuit is enabled.
 494          *  Otherwise this circuit is disabled. The USB block must be powered before
 495          *  selecting the USB setting.
 496          *
 497          *******************************************************************************/
 498          void CyIMO_SetFreq(uint8 freq) 
 499          {
 500   1          uint8 currentFreq;
 501   1          uint8 nextFreq;
 502   1      
 503   1          /***************************************************************************
 504   1          * If the IMO frequency is changed,the Trim values must also be set
 505   1          * accordingly.This requires reading the current frequency. If the new
 506   1          * frequency is faster, then set a new trim and then change the frequency,
 507   1          * otherwise change the frequency and then set new trim values.
 508   1          ***************************************************************************/
 509   1      
 510   1          currentFreq = CY_LIB_FASTCLK_IMO_CR_REG & ((uint8)(~CY_LIB_FASTCLK_IMO_CR_RANGE_MASK));
 511   1      
 512   1          /* Check if requested frequency is USB. */
 513   1          nextFreq = (freq == CY_IMO_FREQ_USB) ? CY_IMO_FREQ_24MHZ : freq;
 514   1      
 515   1          switch (currentFreq)
 516   1          {
 517   2          case 0u:
 518   2              currentFreq = CY_IMO_FREQ_12MHZ;
 519   2              break;
 520   2      
 521   2          case 1u:
 522   2              currentFreq = CY_IMO_FREQ_6MHZ;
 523   2              break;
 524   2      
 525   2          case 2u:
 526   2              currentFreq = CY_IMO_FREQ_24MHZ;
 527   2              break;
 528   2      
 529   2          case 3u:
 530   2              currentFreq = CY_IMO_FREQ_3MHZ;
 531   2              break;
 532   2      
 533   2          case 4u:
 534   2              currentFreq = CY_IMO_FREQ_48MHZ;
 535   2              break;
 536   2      
 537   2          case 5u:
 538   2              currentFreq = CY_IMO_FREQ_62MHZ;
 539   2              break;
 540   2      
 541   2      #if(CY_PSOC5)
                  case 6u:
                      currentFreq = CY_IMO_FREQ_74MHZ;
                      break;
              #endif  /* (CY_PSOC5) */
 546   2      
 547   2          default:
 548   2              CYASSERT(0u != 0u);
 549   2              break;
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 10  

 550   2          }
 551   1      
 552   1          if (nextFreq >= currentFreq)
 553   1          {
 554   2              /* Set new trim first */
 555   2              CyIMO_SetTrimValue(freq);
 556   2          }
 557   1      
 558   1          /* Set usbclk_on bit when using CY_IMO_FREQ_USB, if not clear it */
 559   1          switch(freq)
 560   1          {
 561   2          case CY_IMO_FREQ_3MHZ:
 562   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 563   2                  CY_LIB_IMO_3MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 564   2              break;
 565   2      
 566   2          case CY_IMO_FREQ_6MHZ:
 567   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 568   2                  CY_LIB_IMO_6MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 569   2              break;
 570   2      
 571   2          case CY_IMO_FREQ_12MHZ:
 572   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 573   2                  CY_LIB_IMO_12MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 574   2              break;
 575   2      
 576   2          case CY_IMO_FREQ_24MHZ:
 577   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 578   2                  CY_LIB_IMO_24MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 579   2              break;
 580   2      
 581   2          case CY_IMO_FREQ_48MHZ:
 582   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 583   2                  CY_LIB_IMO_48MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 584   2              break;
 585   2      
 586   2          case CY_IMO_FREQ_62MHZ:
 587   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 588   2                  CY_LIB_IMO_62MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
 589   2              break;
 590   2      
 591   2      #if(CY_PSOC5)
                  case CY_IMO_FREQ_74MHZ:
                      CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
                          CY_LIB_IMO_74MHZ_VALUE) & ((uint8)(~CY_LIB_IMO_USBCLK_ON_SET));
                      break;
              #endif  /* (CY_PSOC5) */
 597   2      
 598   2          case CY_IMO_FREQ_USB:
 599   2              CY_LIB_FASTCLK_IMO_CR_REG = ((CY_LIB_FASTCLK_IMO_CR_REG & CY_LIB_FASTCLK_IMO_CR_RANGE_MASK) |
 600   2                  CY_LIB_IMO_24MHZ_VALUE) | CY_LIB_IMO_USBCLK_ON_SET;
 601   2              break;
 602   2      
 603   2          default:
 604   2              CYASSERT(0u != 0u);
 605   2              break;
 606   2          }
 607   1      
 608   1          /* Tu rn onIMO Doubler, if switching to CY_IMO_FREQ_USB */
 609   1          if (freq == CY_IMO_FREQ_USB)
 610   1          {
 611   2              CyIMO_EnableDoubler();
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 11  

 612   2          }
 613   1          else
 614   1          {
 615   2              CyIMO_DisableDoubler();
 616   2          }
 617   1      
 618   1          if (nextFreq < currentFreq)
 619   1          {
 620   2              /* Set the trim after setting frequency */
 621   2              CyIMO_SetTrimValue(freq);
 622   2          }
 623   1      }
 624          
 625          
 626          /*******************************************************************************
 627          * Function Name: CyIMO_SetSource
 628          ********************************************************************************
 629          *
 630          * Summary:
 631          *  Sets the source of the clock output from the IMO block.
 632          *
 633          *  The output from the IMO is by default the IMO itself. Optionally the MHz
 634          *  Crystal or DSI input can be the source of the IMO output instead.
 635          *
 636          * Parameters:
 637          *   source: CY_IMO_SOURCE_DSI to set the DSI as source.
 638          *           CY_IMO_SOURCE_XTAL to set the MHz as source.
 639          *           CY_IMO_SOURCE_IMO to set the IMO itself.
 640          *
 641          * Return:
 642          *  None
 643          *
 644          * Side Effects:
 645          *  If this function execution resulted in the CPU clock frequency increasing,
 646          *  then the number of clock cycles the cache will wait before it samples data
 647          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 648          *  with an appropriate parameter. It can be optionally called if the CPU clock
 649          *  frequency is lowered in order to improve the CPU performance.
 650          *  See CyFlash_SetWaitCycles() description for more information.
 651          *
 652          *******************************************************************************/
 653          void CyIMO_SetSource(uint8 source) 
 654          {
 655   1          switch(source)
 656   1          {
 657   2          case CY_IMO_SOURCE_DSI:
 658   2              CY_LIB_CLKDIST_CR_REG     &= ((uint8)(~CY_LIB_CLKDIST_CR_IMO2X));
 659   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 660   2              break;
 661   2      
 662   2          case CY_IMO_SOURCE_XTAL:
 663   2              CY_LIB_CLKDIST_CR_REG     |= CY_LIB_CLKDIST_CR_IMO2X;
 664   2              CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_IMO;
 665   2              break;
 666   2      
 667   2          case CY_IMO_SOURCE_IMO:
 668   2              CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_IMO));
 669   2              break;
 670   2      
 671   2          default:
 672   2              /* Incorrect source value */
 673   2              CYASSERT(0u != 0u);
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 12  

 674   2              break;
 675   2          }
 676   1      }
 677          
 678          
 679          /*******************************************************************************
 680          * Function Name: CyIMO_EnableDoubler
 681          ********************************************************************************
 682          *
 683          * Summary:
 684          *  Enables the IMO doubler.  The 2x frequency clock is used to convert a 24 MHz
 685          *  input to a 48 MHz output for use by the USB block.
 686          *
 687          * Parameters:
 688          *  None
 689          *
 690          * Return:
 691          *  None
 692          *
 693          *******************************************************************************/
 694          void CyIMO_EnableDoubler(void) 
 695          {
 696   1          /* Set FASTCLK_IMO_CR_PTR regigster's 4th bit */
 697   1          CY_LIB_FASTCLK_IMO_CR_REG |= CY_LIB_FASTCLK_IMO_DOUBLER;
 698   1      }
 699          
 700          
 701          /*******************************************************************************
 702          * Function Name: CyIMO_DisableDoubler
 703          ********************************************************************************
 704          *
 705          * Summary:
 706          *   Disables the IMO doubler.
 707          *
 708          * Parameters:
 709          *  None
 710          *
 711          * Return:
 712          *  None
 713          *
 714          *******************************************************************************/
 715          void CyIMO_DisableDoubler(void) 
 716          {
 717   1          CY_LIB_FASTCLK_IMO_CR_REG &= ((uint8)(~CY_LIB_FASTCLK_IMO_DOUBLER));
 718   1      }
 719          
 720          
 721          /*******************************************************************************
 722          * Function Name: CyMasterClk_SetSource
 723          ********************************************************************************
 724          *
 725          * Summary:
 726          *  Sets the source of the master clock.
 727          *
 728          * Parameters:
 729          *   source: One of the four available Master clock sources.
 730          *     CY_MASTER_SOURCE_IMO
 731          *     CY_MASTER_SOURCE_PLL
 732          *     CY_MASTER_SOURCE_XTAL
 733          *     CY_MASTER_SOURCE_DSI
 734          *
 735          * Return:
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 13  

 736          *  None
 737          *
 738          * Side Effects:
 739          *  The current source and the new source must both be running and stable before
 740          *  calling this function.
 741          *
 742          *  If this function execution resulted in the CPU clock frequency increasing,
 743          *  then the number of clock cycles the cache will wait before it samples data
 744          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 745          *  with an appropriate parameter. It can be optionally called if the CPU clock
 746          *  frequency is lowered in order to improve the CPU performance.
 747          *  See CyFlash_SetWaitCycles() description for more information.
 748          *
 749          *******************************************************************************/
 750          void CyMasterClk_SetSource(uint8 source) 
 751          {
 752   1          CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & MASTER_CLK_SRC_CLEAR) |
 753   1                                      (source & ((uint8)(~MASTER_CLK_SRC_CLEAR)));
 754   1      }
 755          
 756          
 757          /*******************************************************************************
 758          * Function Name: CyMasterClk_SetDivider
 759          ********************************************************************************
 760          *
 761          * Summary:
 762          *  Sets the divider value used to generate Master Clock.
 763          *
 764          * Parameters:
 765          *  uint8 divider:
 766          *   The valid range is [0-255]. The clock will be divided by this value + 1.
 767          *   For example to divide this parameter by two should be set to 1.
 768          *
 769          * Return:
 770          *  None
 771          *
 772          * Side Effects:
 773          *  If this function execution resulted in the CPU clock frequency increasing,
 774          *  then the number of clock cycles the cache will wait before it samples data
 775          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 776          *  with an appropriate parameter. It can be optionally called if the CPU clock
 777          *  frequency is lowered in order to improve the CPU performance.
 778          *  See CyFlash_SetWaitCycles() description for more information.
 779          *
 780          *  When changing the Master or Bus clock divider value from div-by-n to div-by-1
 781          *  the first clock cycle output after the div-by-1 can be up to 4 ns shorter
 782          *  than the final/expected div-by-1 period.
 783          *
 784          *******************************************************************************/
 785          void CyMasterClk_SetDivider(uint8 divider) 
 786          {
 787   1          CY_LIB_CLKDIST_MSTR0_REG = divider;
 788   1      }
 789          
 790          
 791          /*******************************************************************************
 792          * Function Name: CyBusClk_Internal_SetDivider
 793          ********************************************************************************
 794          *
 795          * Summary:
 796          *  The function used by CyBusClk_SetDivider(). For internal use only.
 797          *
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 14  

 798          * Parameters:
 799          *   divider: Valid range [0-65535].
 800          *   The clock will be divided by this value + 1.
 801          *   For example, to divide this parameter by two should be set to 1.
 802          *
 803          * Return:
 804          *  None
 805          *
 806          *******************************************************************************/
 807          static void CyBusClk_Internal_SetDivider(uint16 divider)
 808          {
 809   1          /* Mask bits to enable shadow loads  */
 810   1          CY_LIB_CLKDIST_AMASK_REG &= CY_LIB_CLKDIST_AMASK_MASK;
 811   1          CY_LIB_CLKDIST_DMASK_REG  = CY_LIB_CLKDIST_DMASK_MASK;
 812   1      
 813   1          /* Enable mask bits to enable shadow loads */
 814   1          CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_MASK;
 815   1      
 816   1          /* Update Shadow Divider Value Register with new divider */
 817   1          CY_LIB_CLKDIST_WRK_LSB_REG = LO8(divider);
 818   1          CY_LIB_CLKDIST_WRK_MSB_REG = HI8(divider);
 819   1      
 820   1      
 821   1          /***************************************************************************
 822   1          * Copy shadow value defined in Shadow Divider Value Register
 823   1          * (CY_LIB_CLKDIST_WRK_LSB_REG and CY_LIB_CLKDIST_WRK_MSB_REG) to all
 824   1          * dividers selected in Analog and Digital Clock Mask Registers
 825   1          * (CY_LIB_CLKDIST_AMASK_REG and CY_LIB_CLKDIST_DMASK_REG).
 826   1          ***************************************************************************/
 827   1          CY_LIB_CLKDIST_LD_REG |= CY_LIB_CLKDIST_LD_LOAD;
 828   1      }
 829          
 830          
 831          /*******************************************************************************
 832          * Function Name: CyBusClk_SetDivider
 833          ********************************************************************************
 834          *
 835          * Summary:
 836          *  Sets the divider value used to generate the Bus Clock.
 837          *
 838          * Parameters:
 839          *  divider: Valid range [0-65535]. The clock will be divided by this value + 1.
 840          *  For example, to divide this parameter by two should be set to 1.
 841          *
 842          * Return:
 843          *  None
 844          *
 845          * Side Effects:
 846          *  If this function execution resulted in the CPU clock frequency increasing,
 847          *  then the number of clock cycles the cache will wait before it samples data
 848          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
 849          *  with an appropriate parameter. It can be optionally called if the CPU clock
 850          *  frequency is lowered in order to improve the CPU performance.
 851          *  See CyFlash_SetWaitCycles() description for more information.
 852          *
 853          *******************************************************************************/
 854          void CyBusClk_SetDivider(uint16 divider) 
 855          {
 856   1          uint8  masterClkDiv;
 857   1          uint16 busClkDiv;
 858   1          uint8 interruptState;
 859   1      
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 15  

 860   1          interruptState = CyEnterCriticalSection();
 861   1      
 862   1          /* Work around to set bus clock divider value */
 863   1          busClkDiv = (uint16)((uint16)CY_LIB_CLKDIST_BCFG_MSB_REG << 8u);
 864   1          busClkDiv |= CY_LIB_CLKDIST_BCFG_LSB_REG;
 865   1      
 866   1          if ((divider == 0u) || (busClkDiv == 0u))
 867   1          {
 868   2              /* Save away master clock divider value */
 869   2              masterClkDiv = CY_LIB_CLKDIST_MSTR0_REG;
 870   2      
 871   2              if (masterClkDiv < CY_LIB_CLKDIST_MASTERCLK_DIV)
 872   2              {
 873   3                  /* Set master clock divider to 7 */
 874   3                  CyMasterClk_SetDivider(CY_LIB_CLKDIST_MASTERCLK_DIV);
 875   3              }
 876   2      
 877   2              if (divider == 0u)
 878   2              {
 879   3                  /* Set SSS bit and divider register desired value */
 880   3                  CY_LIB_CLKDIST_BCFG2_REG |= CY_LIB_CLKDIST_BCFG2_SSS;
 881   3                  CyBusClk_Internal_SetDivider(divider);
 882   3              }
 883   2              else
 884   2              {
 885   3                  CyBusClk_Internal_SetDivider(divider);
 886   3                  CY_LIB_CLKDIST_BCFG2_REG &= ((uint8)(~CY_LIB_CLKDIST_BCFG2_SSS));
 887   3              }
 888   2      
 889   2              /* Restore master clock */
 890   2              CyMasterClk_SetDivider(masterClkDiv);
 891   2          }
 892   1          else
 893   1          {
 894   2              CyBusClk_Internal_SetDivider(divider);
 895   2          }
 896   1      
 897   1          CyExitCriticalSection(interruptState);
 898   1      }
 899          
 900          
 901          #if(CY_PSOC3)
 902          
 903              /*******************************************************************************
 904              * Function Name: CyCpuClk_SetDivider
 905              ********************************************************************************
 906              *
 907              * Summary:
 908              *  Sets the divider value used to generate the CPU Clock. Only applicable for
 909              *  PSoC 3 parts.
 910              *
 911              * Parameters:
 912              *  divider: Valid range [0-15]. The clock will be divided by this value + 1.
 913              *  For example, to divide this parameter by two should be set to 1.
 914              *
 915              * Return:
 916              *  None
 917              *
 918              * Side Effects:
 919              *  If this function execution resulted in the CPU clock frequency increasing,
 920          *  then the number of clock cycles the cache will wait before it samples data
 921          *  coming back from the Flash must be adjusted by calling CyFlash_SetWaitCycles()
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 16  

 922          *  with an appropriate parameter. It can be optionally called if the CPU clock
 923          *  frequency is lowered in order to improve the CPU performance.
 924              *  See CyFlash_SetWaitCycles() description for more information.
 925              *
 926              *******************************************************************************/
 927              void CyCpuClk_SetDivider(uint8 divider) 
 928              {
 929   1                  CY_LIB_CLKDIST_MSTR1_REG = (CY_LIB_CLKDIST_MSTR1_REG & CY_LIB_CLKDIST_MSTR1_DIV_MASK) |
 930   1                                      ((uint8)(divider << CY_LIB_CLKDIST_DIV_POSITION));
 931   1          }
 932          
 933          #endif /* (CY_PSOC3) */
 934          
 935          
 936          /*******************************************************************************
 937          * Function Name: CyUsbClk_SetSource
 938          ********************************************************************************
 939          *
 940          * Summary:
 941          *  Sets the source of the USB clock.
 942          *
 943          * Parameters:
 944          *  source: One of the four available USB clock sources
 945          *    CY_LIB_USB_CLK_IMO2X     - IMO 2x
 946          *    CY_LIB_USB_CLK_IMO       - IMO
 947          *    CY_LIB_USB_CLK_PLL       - PLL
 948          *    CY_LIB_USB_CLK_DSI       - DSI
 949          *
 950          * Return:
 951          *  None
 952          *
 953          *******************************************************************************/
 954          void CyUsbClk_SetSource(uint8 source) 
 955          {
 956   1          CY_LIB_CLKDIST_UCFG_REG = (CY_LIB_CLKDIST_UCFG_REG & ((uint8)(~CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK))) |
 957   1                              (CY_LIB_CLKDIST_UCFG_SRC_SEL_MASK & source);
 958   1      }
 959          
 960          
 961          /*******************************************************************************
 962          * Function Name: CyILO_Start1K
 963          ********************************************************************************
 964          *
 965          * Summary:
 966          *  Enables the ILO 1 KHz oscillator.
 967          *
 968          *  Note The ILO 1 KHz oscillator is always enabled by default, regardless of the
 969          *  selection in the Clock Editor. Therefore, this API is only needed if the
 970          *  oscillator was turned off manually.
 971          *
 972          * Parameters:
 973          *  None
 974          *
 975          * Return:
 976          *  None
 977          *
 978          *******************************************************************************/
 979          void CyILO_Start1K(void) 
 980          {
 981   1          /* Set bit 1 of ILO RS */
 982   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ;
 983   1      }
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 17  

 984          
 985          
 986          /*******************************************************************************
 987          * Function Name: CyILO_Stop1K
 988          ********************************************************************************
 989          *
 990          * Summary:
 991          *  Disables the ILO 1 KHz oscillator.
 992          *
 993          *  Note The ILO 1 KHz oscillator must be enabled if the Sleep or Hibernate low power
 994          *  mode APIs are expected to be used. For more information, refer to the Power
 995          *  Management section of this document.
 996          *
 997          * Parameters:
 998          *  None
 999          *
1000          * Return:
1001          *  None
1002          *
1003          * Side Effects:
1004          *  PSoC5: Stopping the ILO 1 kHz could break the active WDT functionality.
1005          *
1006          *******************************************************************************/
1007          void CyILO_Stop1K(void) 
1008          {
1009   1          /* Clear bit 1 of ILO RS */
1010   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_1KHZ));
1011   1      }
1012          
1013          
1014          /*******************************************************************************
1015          * Function Name: CyILO_Start100K
1016          ********************************************************************************
1017          *
1018          * Summary:
1019          *  Enables the ILO 100 KHz oscillator.
1020          *
1021          * Parameters:
1022          *  None
1023          *
1024          * Return:
1025          *  None
1026          *
1027          *******************************************************************************/
1028          void CyILO_Start100K(void) 
1029          {
1030   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ;
1031   1      }
1032          
1033          
1034          /*******************************************************************************
1035          * Function Name: CyILO_Stop100K
1036          ********************************************************************************
1037          *
1038          * Summary:
1039          *  Disables the ILO 100 KHz oscillator.
1040          *
1041          * Parameters:
1042          *  None
1043          *
1044          * Return:
1045          *  None
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 18  

1046          *
1047          *******************************************************************************/
1048          void CyILO_Stop100K(void) 
1049          {
1050   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ));
1051   1      }
1052          
1053          
1054          /*******************************************************************************
1055          * Function Name: CyILO_Enable33K
1056          ********************************************************************************
1057          *
1058          * Summary:
1059          *  Enables the ILO 33 KHz divider.
1060          *
1061          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator,
1062          *  so it must also be running in order to generate the 33 KHz output.
1063          *
1064          * Parameters:
1065          *  None
1066          *
1067          * Return:
1068          *  None
1069          *
1070          *******************************************************************************/
1071          void CyILO_Enable33K(void) 
1072          {
1073   1          /* Set bit 5 of ILO RS */
1074   1          CY_LIB_SLOWCLK_ILO_CR0_REG |= CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ;
1075   1      }
1076          
1077          
1078          /*******************************************************************************
1079          * Function Name: CyILO_Disable33K
1080          ********************************************************************************
1081          *
1082          * Summary:
1083          *  Disables the ILO 33 KHz divider.
1084          *
1085          *  Note that the 33 KHz clock is generated from the 100 KHz oscillator, but this
1086          *  API does not disable the 100 KHz clock.
1087          *
1088          * Parameters:
1089          *  None
1090          *
1091          * Return:
1092          *  None
1093          *
1094          *******************************************************************************/
1095          void CyILO_Disable33K(void) 
1096          {
1097   1          CY_LIB_SLOWCLK_ILO_CR0_REG &= ((uint8)(~CY_LIB_SLOWCLK_ILO_CR0_EN_33KHZ));
1098   1      }
1099          
1100          
1101          /*******************************************************************************
1102          * Function Name: CyILO_SetSource
1103          ********************************************************************************
1104          *
1105          * Summary:
1106          *  Sets the source of the clock output from the ILO block.
1107          *
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 19  

1108          * Parameters:
1109          *  source: One of the three available ILO output sources
1110          *       Value        Define                Source
1111          *       0            CY_ILO_SOURCE_100K    ILO 100 KHz
1112          *       1            CY_ILO_SOURCE_33K     ILO 33 KHz
1113          *       2            CY_ILO_SOURCE_1K      ILO 1 KHz
1114          *
1115          * Return:
1116          *  None
1117          *
1118          *******************************************************************************/
1119          void CyILO_SetSource(uint8 source) 
1120          {
1121   1          CY_LIB_CLKDIST_CR_REG = (CY_LIB_CLKDIST_CR_REG & CY_ILO_SOURCE_BITS_CLEAR) |
1122   1                          (((uint8) (source << 2u)) & ((uint8)(~CY_ILO_SOURCE_BITS_CLEAR)));
1123   1      }
1124          
1125          
1126          /*******************************************************************************
1127          * Function Name: CyILO_SetPowerMode
1128          ********************************************************************************
1129          *
1130          * Summary:
1131          *  Sets the power mode used by the ILO during power down. Allows for lower power
1132          *  down power usage resulting in a slower startup time.
1133          *
1134          * Parameters:
1135          *  uint8 mode
1136          *   CY_ILO_FAST_START - Faster start-up, internal bias left on when powered down
1137          *   CY_ILO_SLOW_START - Slower start-up, internal bias off when powered down
1138          *
1139          * Return:
1140          *   Prevous power mode state.
1141          *
1142          *******************************************************************************/
1143          uint8 CyILO_SetPowerMode(uint8 mode) 
1144          {
1145   1          uint8 state;
1146   1      
1147   1          /* Get current state. */
1148   1          state = CY_LIB_SLOWCLK_ILO_CR0_REG;
1149   1      
1150   1          /* Set the oscillator power mode. */
1151   1          if(mode != CY_ILO_FAST_START)
1152   1          {
1153   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state | CY_ILO_CONTROL_PD_MODE);
1154   2          }
1155   1          else
1156   1          {
1157   2              CY_LIB_SLOWCLK_ILO_CR0_REG = (state & ((uint8)(~CY_ILO_CONTROL_PD_MODE)));
1158   2          }
1159   1      
1160   1          /* Return old mode. */
1161   1          return ((state & CY_ILO_CONTROL_PD_MODE) >> CY_ILO_CONTROL_PD_POSITION);
1162   1      }
1163          
1164          
1165          /*******************************************************************************
1166          * Function Name: CyXTAL_32KHZ_Start
1167          ********************************************************************************
1168          *
1169          * Summary:
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 20  

1170          *  Enables the 32 KHz Crystal Oscillator.
1171          *
1172          * Parameters:
1173          *  None
1174          *
1175          * Return:
1176          *  None
1177          *
1178          *******************************************************************************/
1179          void CyXTAL_32KHZ_Start(void) 
1180          {
1181   1          volatile uint16 i;
1182   1      
1183   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1184   1          CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_STARTUP;
1185   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1186   1                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1187   1      
1188   1          #if(CY_PSOC3)
1189   1              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_PDBEN;
1190   1          #endif  /* (CY_PSOC3) */
1191   1      
1192   1          /* Enable operation of 32K Crystal Oscillator */
1193   1          CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_EN;
1194   1      
1195   1          for (i = 1000u; i > 0u; i--)
1196   1          {
1197   2              if(0u != (CyXTAL_32KHZ_ReadStatus() & CY_XTAL32K_ANA_STAT))
1198   2              {
1199   3                  /* Ready - switch to high power mode */
1200   3                  (void) CyXTAL_32KHZ_SetPowerMode(0u);
1201   3      
1202   3                  break;
1203   3              }
1204   2              CyDelayUs(1u);
1205   2          }
1206   1      }
1207          
1208          
1209          /*******************************************************************************
1210          * Function Name: CyXTAL_32KHZ_Stop
1211          ********************************************************************************
1212          *
1213          * Summary:
1214          *  Disables the 32KHz Crystal Oscillator.
1215          *
1216          * Parameters:
1217          *  None
1218          *
1219          * Return:
1220          *  None
1221          *
1222          *******************************************************************************/
1223          void CyXTAL_32KHZ_Stop(void) 
1224          {
1225   1          CY_CLK_XTAL32_TST_REG  = CY_CLK_XTAL32_TST_DEFAULT;
1226   1          CY_CLK_XTAL32_TR_REG   = CY_CLK_XTAL32_TR_POWERDOWN;
1227   1          CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1228   1                                   CY_CLK_XTAL32_CFG_LP_DEFAULT;
1229   1          CY_CLK_XTAL32_CR_REG &= ((uint8)(~(CY_CLK_XTAL32_CR_EN | CY_CLK_XTAL32_CR_LPM)));
1230   1      
1231   1          #if(CY_PSOC3)
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 21  

1232   1              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_PDBEN));
1233   1          #endif  /* (CY_PSOC3) */
1234   1      }
1235          
1236          
1237          /*******************************************************************************
1238          * Function Name: CyXTAL_32KHZ_ReadStatus
1239          ********************************************************************************
1240          *
1241          * Summary:
1242          *  Returns status of the 32 KHz oscillator.
1243          *
1244          * Parameters:
1245          *  None
1246          *
1247          * Return:
1248          *  Value     Define                    Source
1249          *  20        CY_XTAL32K_ANA_STAT       Analog measurement
1250          *                                       1: Stable
1251          *                                       0: Not stable
1252          *
1253          *******************************************************************************/
1254          uint8 CyXTAL_32KHZ_ReadStatus(void) 
1255          {
1256   1          return(CY_CLK_XTAL32_CR_REG & CY_XTAL32K_ANA_STAT);
1257   1      }
1258          
1259          
1260          /*******************************************************************************
1261          * Function Name: CyXTAL_32KHZ_SetPowerMode
1262          ********************************************************************************
1263          *
1264          * Summary:
1265          *  Sets the power mode for the 32 KHz oscillator used during the sleep mode.
1266          *  Allows for lower power during sleep when there are fewer sources of noise.
1267          *  During the active mode the oscillator is always run in the high power mode.
1268          *
1269          * Parameters:
1270          *  uint8 mode
1271          *       0: High power mode
1272          *       1: Low power mode during sleep
1273          *
1274          * Return:
1275          *  Previous power mode.
1276          *
1277          *******************************************************************************/
1278          uint8 CyXTAL_32KHZ_SetPowerMode(uint8 mode) 
1279          {
1280   1          uint8 state = (0u != (CY_CLK_XTAL32_CR_REG & CY_CLK_XTAL32_CR_LPM)) ? 1u : 0u;
1281   1      
1282   1          CY_CLK_XTAL32_TST_REG = CY_CLK_XTAL32_TST_DEFAULT;
1283   1      
1284   1          if(1u == mode)
1285   1          {
1286   2              /* Low power mode during Sleep */
1287   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_LOW_POWER;
1288   2              CyDelayUs(10u);
1289   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1290   2                                      CY_CLK_XTAL32_CFG_LP_LOWPOWER;
1291   2              CyDelayUs(20u);
1292   2              CY_CLK_XTAL32_CR_REG |= CY_CLK_XTAL32_CR_LPM;
1293   2          }
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 22  

1294   1          else
1295   1          {
1296   2              /* High power mode */
1297   2              CY_CLK_XTAL32_TR_REG  = CY_CLK_XTAL32_TR_HIGH_POWER;
1298   2              CyDelayUs(10u);
1299   2              CY_CLK_XTAL32_CFG_REG = (CY_CLK_XTAL32_CFG_REG & ((uint8)(~CY_CLK_XTAL32_CFG_LP_MASK))) |
1300   2                                      CY_CLK_XTAL32_CFG_LP_DEFAULT;
1301   2              CY_CLK_XTAL32_CR_REG &= ((uint8)(~CY_CLK_XTAL32_CR_LPM));
1302   2          }
1303   1      
1304   1          return(state);
1305   1      }
1306          
1307          
1308          /*******************************************************************************
1309          * Function Name: CyXTAL_Start
1310          ********************************************************************************
1311          *
1312          * Summary:
1313          *  Enables the megahertz crystal.
1314          *
1315          *  PSoC 3:
1316          *  Waits until the XERR bit is low (no error) for a millisecond or until the
1317          *  number of milliseconds specified by the wait parameter has expired.
1318          *
1319          * Parameters:
1320          *   wait: Valid range [0-255].
1321          *   This is the timeout value in milliseconds.
1322          *   The appropriate value is crystal specific.
1323          *
1324          * Return:
1325          *   CYRET_SUCCESS - Completed successfully
1326          *   CYRET_TIMEOUT - Timeout occurred without detecting a low value on XERR.
1327          *
1328          * Side Effects and Restrictions:
1329          *  If wait is enabled (non-zero wait). Uses the Fast Timewheel to time the wait.
1330          *  Any other use of the Fast Timewheel (FTW) will be stopped during the period
1331          *  of this function and then restored.
1332          *
1333          *  Uses the 100KHz ILO.  If not enabled, this function will enable the 100KHz
1334          *  ILO for the period of this function. No changes to the setup of the ILO,
1335          *  Fast Timewheel, Central Timewheel or Once Per Second interrupt may be made
1336          *  by interrupt routines during the period of this function.
1337          *
1338          *  The current operation of the ILO, Central Timewheel and Once Per Second
1339          *  interrupt are maintained during the operation of this function provided the
1340          *  reading of the Power Manager Interrupt Status Register is only done using the
1341          *  CyPmReadStatus() function.
1342          *
1343          *******************************************************************************/
1344          cystatus CyXTAL_Start(uint8 wait) 
1345          {
1346   1          cystatus status = CYRET_SUCCESS;
1347   1          volatile uint8  timeout = wait;
1348   1          volatile uint8 count;
1349   1          uint8 iloEnableState;
1350   1          uint8 pmTwCfg0Tmp;
1351   1          uint8 pmTwCfg2Tmp;
1352   1      
1353   1      
1354   1          /* Enables MHz crystal oscillator circuit  */
1355   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_ENABLE;
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 23  

1356   1      
1357   1      
1358   1          if(wait > 0u)
1359   1          {
1360   2              /* Save 100 KHz ILO, FTW interval, enable and interrupt enable */
1361   2              iloEnableState = CY_LIB_SLOWCLK_ILO_CR0_REG;
1362   2              pmTwCfg0Tmp = CY_LIB_PM_TW_CFG0_REG;
1363   2              pmTwCfg2Tmp = CY_LIB_PM_TW_CFG2_REG;
1364   2      
1365   2              /* Set 250 us interval */
1366   2              CyPmFtwSetInterval(CY_CLK_XMHZ_FTW_INTERVAL);
1367   2              status = CYRET_TIMEOUT;
1368   2      
1369   2      
1370   2              for( ; timeout > 0u; timeout--)
1371   2              {
1372   3                  /* Read XERR bit to clear it */
1373   3                  (void) CY_CLK_XMHZ_CSR_REG;
1374   3      
1375   3                  /* Wait for 1 millisecond - 4 x 250 us */
1376   3                  for(count = 4u; count > 0u; count--)
1377   3                  {
1378   4                      while(0u == (CY_PM_FTW_INT & CyPmReadStatus(CY_PM_FTW_INT)))
1379   4                      {
1380   5                          /* Wait for FTW interrupt event */
1381   5                      }
1382   4                  }
1383   3      
1384   3      
1385   3                  /*******************************************************************
1386   3                  * High output indicates an oscillator failure.
1387   3                  * Only can be used after a start-up interval (1 ms) is completed.
1388   3                  *******************************************************************/
1389   3                  if(0u == (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR))
1390   3                  {
1391   4                      status = CYRET_SUCCESS;
1392   4                      break;
1393   4                  }
1394   3              }
1395   2      
1396   2      
1397   2              /* Restore 100 KHz ILO, FTW interval, enable and interrupt enable */
1398   2              if(0u == (iloEnableState & CY_LIB_SLOWCLK_ILO_CR0_EN_100KHZ))
1399   2              {
1400   3                  CyILO_Stop100K();
1401   3              }
1402   2              CY_LIB_PM_TW_CFG0_REG = pmTwCfg0Tmp;
1403   2              CY_LIB_PM_TW_CFG2_REG = pmTwCfg2Tmp;
1404   2          }
1405   1      
1406   1          return(status);
1407   1      }
1408          
1409          
1410          /*******************************************************************************
1411          * Function Name: CyXTAL_Stop
1412          ********************************************************************************
1413          *
1414          * Summary:
1415          *  Disables the megahertz crystal oscillator.
1416          *
1417          * Parameters:
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 24  

1418          *  None
1419          *
1420          * Return:
1421          *  None
1422          *
1423          *******************************************************************************/
1424          void CyXTAL_Stop(void) 
1425          {
1426   1          /* Disable oscillator. */
1427   1          FASTCLK_XMHZ_CSR &= ((uint8)(~XMHZ_CONTROL_ENABLE));
1428   1      }
1429          
1430          
1431          /*******************************************************************************
1432          * Function Name: CyXTAL_EnableErrStatus
1433          ********************************************************************************
1434          *
1435          * Summary:
1436          *  Enables the generation of the XERR status bit for the megahertz crystal.
1437          *  This function is not available for PSoC5.
1438          *
1439          * Parameters:
1440          *  None
1441          *
1442          * Return:
1443          *  None
1444          *
1445          *******************************************************************************/
1446          void CyXTAL_EnableErrStatus(void) 
1447          {
1448   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1449   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XFB));
1450   1      }
1451          
1452          
1453          /*******************************************************************************
1454          * Function Name: CyXTAL_DisableErrStatus
1455          ********************************************************************************
1456          *
1457          * Summary:
1458          *  Disables the generation of the XERR status bit for the megahertz crystal.
1459          *  This function is not available for PSoC5.
1460          *
1461          * Parameters:
1462          *  None
1463          *
1464          * Return:
1465          *  None
1466          *
1467          *******************************************************************************/
1468          void CyXTAL_DisableErrStatus(void) 
1469          {
1470   1          /* If oscillator has insufficient amplitude, XERR bit will be high. */
1471   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XFB;
1472   1      }
1473          
1474          
1475          /*******************************************************************************
1476          * Function Name: CyXTAL_ReadStatus
1477          ********************************************************************************
1478          *
1479          * Summary:
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 25  

1480          *  Reads the XERR status bit for the megahertz crystal. This status bit is a
1481          *  sticky, clear on read. This function is not available for PSoC5.
1482          *
1483          * Parameters:
1484          *  None
1485          *
1486          * Return:
1487          *   Status
1488          *    0: No error
1489          *    1: Error
1490          *
1491          *******************************************************************************/
1492          uint8 CyXTAL_ReadStatus(void) 
1493          {
1494   1          /***************************************************************************
1495   1          * High output indicates an oscillator failure. Only use this after a start-up
1496   1          * interval is completed. This can be used for the status and failure recovery.
1497   1          ***************************************************************************/
1498   1          return((0u != (CY_CLK_XMHZ_CSR_REG & CY_CLK_XMHZ_CSR_XERR)) ? 1u : 0u);
1499   1      }
1500          
1501          
1502          /*******************************************************************************
1503          * Function Name: CyXTAL_EnableFaultRecovery
1504          ********************************************************************************
1505          *
1506          * Summary:
1507          *  Enables the fault recovery circuit which will switch to the IMO in the case
1508          *  of a fault in the megahertz crystal circuit. The crystal must be up and
1509          *  running with the XERR bit at 0, before calling this function to prevent
1510          *  an immediate fault switchover. This function is not available for PSoC5.
1511          *
1512          * Parameters:
1513          *  None
1514          *
1515          * Return:
1516          *  None
1517          *
1518          *******************************************************************************/
1519          void CyXTAL_EnableFaultRecovery(void) 
1520          {
1521   1          CY_CLK_XMHZ_CSR_REG |= CY_CLK_XMHZ_CSR_XPROT;
1522   1      }
1523          
1524          
1525          /*******************************************************************************
1526          * Function Name: CyXTAL_DisableFaultRecovery
1527          ********************************************************************************
1528          *
1529          * Summary:
1530          *  Disables the fault recovery circuit which will switch to the IMO in the case
1531          *  of a fault in the megahertz crystal circuit. This function is not available
1532          *  for PSoC5.
1533          *
1534          * Parameters:
1535          *  None
1536          *
1537          * Return:
1538          *  None
1539          *
1540          *******************************************************************************/
1541          void CyXTAL_DisableFaultRecovery(void) 
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 26  

1542          {
1543   1          CY_CLK_XMHZ_CSR_REG &= ((uint8)(~CY_CLK_XMHZ_CSR_XPROT));
1544   1      }
1545          
1546          
1547          /*******************************************************************************
1548          * Function Name: CyXTAL_SetStartup
1549          ********************************************************************************
1550          *
1551          * Summary:
1552          *  Sets the startup settings for the crystal. The logic model outputs a frequency
1553          *  (setting + 4) MHz when enabled.
1554          *
1555          *  This is artificial as the actual frequency is determined by an attached
1556          *  external crystal.
1557          *
1558          * Parameters:
1559          *  setting: Valid range [0-31].
1560          *   The value is dependent on the frequency and quality of the crystal being used.
1561          *   Refer to the device TRM and datasheet for more information.
1562          *
1563          * Return:
1564          *  None
1565          *
1566          *******************************************************************************/
1567          void CyXTAL_SetStartup(uint8 setting) 
1568          {
1569   1          CY_CLK_XMHZ_CFG0_REG = (CY_CLK_XMHZ_CFG0_REG & ((uint8)(~CY_CLK_XMHZ_CFG0_XCFG_MASK))) |
1570   1                                 (setting & CY_CLK_XMHZ_CFG0_XCFG_MASK);
1571   1      }
1572          
1573          
1574          
1575          /*******************************************************************************
1576          * Function Name: CyXTAL_SetFbVoltage
1577          ********************************************************************************
1578          *
1579          * Summary:
1580          *  Sets the feedback reference voltage to use for the crystal circuit.
1581          *  This function is only available for PSoC3 and PSoC 5LP.
1582          *
1583          * Parameters:
1584          *  setting: Valid range [0-15].
1585          *  Refer to the device TRM and datasheet for more information.
1586          *
1587          * Return:
1588          *  None
1589          *
1590          *******************************************************************************/
1591          void CyXTAL_SetFbVoltage(uint8 setting) 
1592          {
1593   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_FB_MASK))) |
1594   1                                  (setting & CY_CLK_XMHZ_CFG1_VREF_FB_MASK));
1595   1      }
1596          
1597          
1598          /*******************************************************************************
1599          * Function Name: CyXTAL_SetWdVoltage
1600          ********************************************************************************
1601          *
1602          * Summary:
1603          *  Sets the reference voltage used by the watchdog to detect a failure in the
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 27  

1604          *  crystal circuit. This function is only available for PSoC3 and PSoC 5LP.
1605          *
1606          * Parameters:
1607          *  setting: Valid range [0-7].
1608          *  Refer to the device TRM and datasheet for more information.
1609          *
1610          * Return:
1611          *  None
1612          *
1613          *******************************************************************************/
1614          void CyXTAL_SetWdVoltage(uint8 setting) 
1615          {
1616   1          CY_CLK_XMHZ_CFG1_REG = ((CY_CLK_XMHZ_CFG1_REG & ((uint8)(~CY_CLK_XMHZ_CFG1_VREF_WD_MASK))) |
1617   1                                  (((uint8)(setting << 4u)) & CY_CLK_XMHZ_CFG1_VREF_WD_MASK));
1618   1      }
1619          
1620          
1621          /*******************************************************************************
1622          * Function Name: CyHalt
1623          ********************************************************************************
1624          *
1625          * Summary:
1626          *  Halts the CPU.
1627          *
1628          * Parameters:
1629          *  uint8 reason: Value to be used during debugging.
1630          *
1631          * Return:
1632          *  None
1633          *
1634          *******************************************************************************/
1635          void CyHalt(uint8 reason) CYREENTRANT
1636          {
1637   1          if(0u != reason)
1638   1          {
1639   2              /* To remove unreferenced local variable warning */
1640   2          }
1641   1      
1642   1          #if defined (__ARMCC_VERSION)
                      __breakpoint(0x0);
                  #elif defined(__GNUC__) || defined (__ICCARM__)
                      __asm("    bkpt    1");
                  #elif defined(__C51__)
1647   1              CYDEV_HALT_CPU;
1648   1          #endif  /* (__ARMCC_VERSION) */
1649   1      }
1650          
1651          
1652          /*******************************************************************************
1653          * Function Name: CySoftwareReset
1654          ********************************************************************************
1655          *
1656          * Summary:
1657          *  Forces a device software reset.
1658          *
1659          * Parameters:
1660          *  None
1661          *
1662          * Return:
1663          *  None
1664          *
1665          *******************************************************************************/
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 28  

1666          void CySoftwareReset(void) 
1667          {
1668   1          CY_LIB_RESET_CR2_REG |= CY_LIB_RESET_CR2_RESET;
1669   1      }
1670          
1671          
1672          /*******************************************************************************
1673          * Function Name: CyDelay
1674          ********************************************************************************
1675          *
1676          * Summary:
1677          *  Blocks for milliseconds.
1678          *
1679          *  Note:
1680          *  CyDelay has been implemented with the instruction cache assumed enabled. When
1681          *  the instruction cache is disabled on PSoC5, CyDelay will be two times larger.
1682          *  For example, with instruction cache disabled CyDelay(100) would result in
1683          *  about 200 ms delay instead of 100 ms.
1684          *
1685          * Parameters:
1686          *  milliseconds: number of milliseconds to delay.
1687          *
1688          * Return:
1689          *   None
1690          *
1691          *******************************************************************************/
1692          void CyDelay(uint32 milliseconds) CYREENTRANT
1693          {
1694   1          while (milliseconds > 32768u)
1695   1          {
1696   2              /***********************************************************************
1697   2              * This loop prevents overflow.At 100MHz, milliseconds * delay_freq_khz
1698   2              * overflows at about 42 seconds.
1699   2              ***********************************************************************/
1700   2              CyDelayCycles(cydelay_32k_ms);
1701   2              milliseconds = ((uint32)(milliseconds - 32768u));
1702   2          }
1703   1      
1704   1          CyDelayCycles(milliseconds * cydelay_freq_khz);
1705   1      }
1706          
1707          
1708          #if(!CY_PSOC3)
              
                  /* For PSoC3 devices function is defined in CyBootAsmKeil.a51 file */
              
                  /*******************************************************************************
                  * Function Name: CyDelayUs
                  ********************************************************************************
                  *
                  * Summary:
                  *  Blocks for microseconds.
                  *
                  *  Note:
                  *   CyDelay has been implemented with the instruction cache assumed enabled.
                  *   When instruction cache is disabled on PSoC5, CyDelayUs will be two times
                  *   larger. Ex: With instruction cache disabled CyDelayUs(100) would result
                  *   in about 200us delay instead of 100us.
                  *
                  * Parameters:
                  *  uint16 microseconds: number of microseconds to delay.
                  *
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 29  

                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  CyDelayUS has been implemented with the instruction cache assumed enabled.
                  *  When the instruction cache is disabled on PSoC 5, CyDelayUs will be two times
                  *  larger. For example, with the instruction cache disabled CyDelayUs(100) would
                  *  result in about 200 us delay instead of 100 us.
                  *
                  *  If the bus clock frequency is a small non-integer number, the actual delay
                  *  can be up to twice as long as the nominal value. The actual delay cannot be
                  *  shorter than the nominal one.
                  *******************************************************************************/
                  void CyDelayUs(uint16 microseconds) CYREENTRANT
                  {
                      CyDelayCycles((uint32)microseconds * cydelay_freq_mhz);
                  }
              
              #endif  /* (!CY_PSOC3) */
1747          
1748          
1749          /*******************************************************************************
1750          * Function Name: CyDelayFreq
1751          ********************************************************************************
1752          *
1753          * Summary:
1754          *  Sets the clock frequency for CyDelay.
1755          *
1756          * Parameters:
1757          *  freq: The frequency of the bus clock in Hertz.
1758          *
1759          * Return:
1760          *  None
1761          *
1762          *******************************************************************************/
1763          void CyDelayFreq(uint32 freq) CYREENTRANT
1764          {
1765   1          if (freq != 0u)
1766   1          {
1767   2              cydelay_freq_hz = freq;
1768   2          }
1769   1          else
1770   1          {
1771   2              cydelay_freq_hz = BCLK__BUS_CLK__HZ;
1772   2          }
1773   1      
1774   1          cydelay_freq_mhz = (uint8)((cydelay_freq_hz + 999999u) / 1000000u);
1775   1          cydelay_freq_khz = (cydelay_freq_hz + 999u) / 1000u;
1776   1          cydelay_32k_ms   = 32768u * cydelay_freq_khz;
1777   1      }
1778          
1779          
1780          /*******************************************************************************
1781          * Function Name: CyWdtStart
1782          ********************************************************************************
1783          *
1784          * Summary:
1785          *  Enables the watchdog timer.
1786          *
1787          *  The timer is configured for the specified count interval, the central
1788          *  timewheel is cleared, the setting for the low power mode is configured and the
1789          *  watchdog timer is enabled.
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 30  

1790          *
1791          *  Once enabled the watchdog cannot be disabled. The watchdog counts each time
1792          *  the Central Time Wheel (CTW) reaches the period specified. The watchdog must
1793          *  be cleared using the CyWdtClear() function before three ticks of the watchdog
1794          *  timer occur. The CTW is free running, so this will occur after between 2 and
1795          *  3 timer periods elapse.
1796          *
1797          *  PSoC5: The watchdog timer should not be used during sleep modes. Since the
1798          *  WDT cannot be disabled after it is enabled, the WDT timeout period can be
1799          *  set to be greater than the sleep wakeup period, then feed the dog on each
1800          *  wakeup from Sleep.
1801          *
1802          * Parameters:
1803          *  ticks: One of the four available timer periods. Once WDT enabled, the
1804             interval cannot be changed.
1805          *         CYWDT_2_TICKS     -     4 - 6     ms
1806          *         CYWDT_16_TICKS    -    32 - 48    ms
1807          *         CYWDT_128_TICKS   -   256 - 384   ms
1808          *         CYWDT_1024_TICKS  - 2.048 - 3.072 s
1809          *
1810          *  lpMode: Low power mode configuration. This parameter is ignored for PSoC 5.
1811          *          The WDT always acts as if CYWDT_LPMODE_NOCHANGE is passed.
1812          *
1813          *          CYWDT_LPMODE_NOCHANGE - No Change
1814          *          CYWDT_LPMODE_MAXINTER - Switch to longest timer mode during low power
1815          *                                 mode
1816          *          CYWDT_LPMODE_DISABLED - Disable WDT during low power mode
1817          *
1818          * Return:
1819          *  None
1820          *
1821          * Side Effects:
1822          *  PSoC5: The ILO 1 KHz must be enabled for proper WDT operation. Stopping the
1823          *  ILO 1 kHz could break the active WDT functionality.
1824          *
1825          *******************************************************************************/
1826          void CyWdtStart(uint8 ticks, uint8 lpMode) 
1827          {
1828   1          /* Set WDT interval */
1829   1          CY_WDT_CFG_REG = (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_INTERVAL_MASK))) | (ticks & CY_WDT_CFG_INTERVA
             -L_MASK);
1830   1      
1831   1          /* Reset CTW to ensure that first watchdog period is full */
1832   1          CY_WDT_CFG_REG |= CY_WDT_CFG_CTW_RESET;
1833   1          CY_WDT_CFG_REG &= ((uint8)(~CY_WDT_CFG_CTW_RESET));
1834   1      
1835   1          /* Setting low power mode */
1836   1          CY_WDT_CFG_REG = (((uint8)(lpMode << CY_WDT_CFG_LPMODE_SHIFT)) & CY_WDT_CFG_LPMODE_MASK) |
1837   1                             (CY_WDT_CFG_REG & ((uint8)(~CY_WDT_CFG_LPMODE_MASK)));
1838   1      
1839   1          /* Enables watchdog reset */
1840   1          CY_WDT_CFG_REG |= CY_WDT_CFG_WDR_EN;
1841   1      }
1842          
1843          
1844          /*******************************************************************************
1845          * Function Name: CyWdtClear
1846          ********************************************************************************
1847          *
1848          * Summary:
1849          *  Clears (feeds) the watchdog timer.
1850          *
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 31  

1851          * Parameters:
1852          *  None
1853          *
1854          * Return:
1855          *  None
1856          *
1857          *******************************************************************************/
1858          void CyWdtClear(void) 
1859          {
1860   1          CY_WDT_CR_REG = CY_WDT_CR_FEED;
1861   1      }
1862          
1863          
1864          
1865          /*******************************************************************************
1866          * Function Name: CyVdLvDigitEnable
1867          ********************************************************************************
1868          *
1869          * Summary:
1870          *  Enables the digital low voltage monitors to generate interrupt on Vddd
1871          *   archives specified threshold and optionally resets the device.
1872          *
1873          * Parameters:
1874          *  reset: The option to reset the device at a specified Vddd threshold:
1875          *           0 - Device is not reset.
1876          *           1 - Device is reset.
1877          *
1878          *  threshold: Sets the trip level for the voltage monitor.
1879          *  Values from 1.70 V to 5.45 V are accepted with an interval  of approximately
1880          *  250 mV.
1881          *
1882          * Return:
1883          *  None
1884          *
1885          *******************************************************************************/
1886          void CyVdLvDigitEnable(uint8 reset, uint8 threshold) 
1887          {
1888   1          *CY_INT_CLEAR_PTR = 0x01u;
1889   1      
1890   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1891   1      
1892   1          CY_VD_LVI_TRIP_REG = (threshold & CY_VD_LVI_TRIP_LVID_MASK) |
1893   1                                  (CY_VD_LVI_TRIP_REG & ((uint8)(~CY_VD_LVI_TRIP_LVID_MASK)));
1894   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVID_EN;
1895   1      
1896   1          /* Timeout to eliminate glitches on LVI/HVI when enabling */
1897   1          CyDelayUs(1u);
1898   1      
1899   1          (void)CY_VD_PERSISTENT_STATUS_REG;
1900   1      
1901   1          if(0u != reset)
1902   1          {
1903   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESD_EN;
1904   2          }
1905   1          else
1906   1          {
1907   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1908   2          }
1909   1      
1910   1          *CY_INT_CLR_PEND_PTR = 0x01u;
1911   1          *CY_INT_ENABLE_PTR   = 0x01u;
1912   1      }
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 32  

1913          
1914          
1915          /*******************************************************************************
1916          * Function Name: CyVdLvAnalogEnable
1917          ********************************************************************************
1918          *
1919          * Summary:
1920          *  Enables the analog low voltage monitors to generate interrupt on Vdda
1921          *   archives specified threshold and optionally resets the device.
1922          *
1923          * Parameters:
1924          *  reset: The option to reset the device at a specified Vdda threshold:
1925          *           0 - Device is not reset.
1926          *           1 - Device is reset.
1927          *
1928          *  threshold: Sets the trip level for the voltage monitor.
1929          *  Values from 1.70 V to 5.45 V are accepted with the approximately 250 mV
1930          *  interval.
1931          *
1932          * Return:
1933          *  None
1934          *
1935          *******************************************************************************/
1936          void CyVdLvAnalogEnable(uint8 reset, uint8 threshold) 
1937          {
1938   1          *CY_INT_CLEAR_PTR = 0x01u;
1939   1      
1940   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
1941   1      
1942   1          CY_VD_LVI_TRIP_REG = ((uint8)(threshold << 4u)) | (CY_VD_LVI_TRIP_REG & 0x0Fu);
1943   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_LVIA_EN;
1944   1      
1945   1          /* Timeout to eliminate glitches on LVI/HVI when enabling */
1946   1          CyDelayUs(1u);
1947   1      
1948   1          (void)CY_VD_PERSISTENT_STATUS_REG;
1949   1      
1950   1          if(0u != reset)
1951   1          {
1952   2              CY_VD_PRES_CONTROL_REG |= CY_VD_PRESA_EN;
1953   2          }
1954   1          else
1955   1          {
1956   2              CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
1957   2          }
1958   1      
1959   1          *CY_INT_CLR_PEND_PTR = 0x01u;
1960   1          *CY_INT_ENABLE_PTR   = 0x01u;
1961   1      }
1962          
1963          
1964          /*******************************************************************************
1965          * Function Name: CyVdLvDigitDisable
1966          ********************************************************************************
1967          *
1968          * Summary:
1969          *  Disables the digital low voltage monitor (interrupt and device reset are
1970          *  disabled).
1971          *
1972          * Parameters:
1973          *  None
1974          *
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 33  

1975          * Return:
1976          *  None
1977          *
1978          *******************************************************************************/
1979          void CyVdLvDigitDisable(void) 
1980          {
1981   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVID_EN));
1982   1      
1983   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESD_EN));
1984   1      
1985   1          while(0u != (CY_VD_PERSISTENT_STATUS_REG & 0x07u))
1986   1          {
1987   2      
1988   2          }
1989   1      }
1990          
1991          
1992          /*******************************************************************************
1993          * Function Name: CyVdLvAnalogDisable
1994          ********************************************************************************
1995          *
1996          * Summary:
1997          *  Disables the analog low voltage monitor (interrupt and device reset are
1998          *  disabled).
1999          *
2000          * Parameters:
2001          *  None
2002          *
2003          * Return:
2004          *  None
2005          *
2006          *******************************************************************************/
2007          void CyVdLvAnalogDisable(void) 
2008          {
2009   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_LVIA_EN));
2010   1      
2011   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2012   1      
2013   1          while(0u != (CY_VD_PERSISTENT_STATUS_REG & 0x07u))
2014   1          {
2015   2      
2016   2          }
2017   1      }
2018          
2019          
2020          /*******************************************************************************
2021          * Function Name: CyVdHvAnalogEnable
2022          ********************************************************************************
2023          *
2024          * Summary:
2025          *  Enables the analog high voltage monitors to generate interrupt on
2026          *  Vdda archives 5.75 V threshold and optionally resets device.
2027          *
2028          * Parameters:
2029          *  None
2030          *
2031          * Return:
2032          *  None
2033          *
2034          *******************************************************************************/
2035          void CyVdHvAnalogEnable(void) 
2036          {
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 34  

2037   1          *CY_INT_CLEAR_PTR = 0x01u;
2038   1      
2039   1          CY_VD_PRES_CONTROL_REG &= ((uint8)(~CY_VD_PRESA_EN));
2040   1      
2041   1          CY_VD_LVI_HVI_CONTROL_REG |= CY_VD_HVIA_EN;
2042   1      
2043   1          /* Timeout to eliminate glitches on the LVI/HVI when enabling */
2044   1          CyDelayUs(1u);
2045   1      
2046   1          (void) CY_VD_PERSISTENT_STATUS_REG;
2047   1      
2048   1          *CY_INT_CLR_PEND_PTR = 0x01u;
2049   1          *CY_INT_ENABLE_PTR   = 0x01u;
2050   1      }
2051          
2052          
2053          /*******************************************************************************
2054          * Function Name: CyVdHvAnalogDisable
2055          ********************************************************************************
2056          *
2057          * Summary:
2058          *  Disables the analog low voltage monitor
2059          *  (interrupt and device reset are disabled).
2060          *
2061          * Parameters:
2062          *  None
2063          *
2064          * Return:
2065          *  None
2066          *
2067          *******************************************************************************/
2068          void CyVdHvAnalogDisable(void) 
2069          {
2070   1          CY_VD_LVI_HVI_CONTROL_REG &= ((uint8)(~CY_VD_HVIA_EN));
2071   1      }
2072          
2073          
2074          /*******************************************************************************
2075          * Function Name: CyVdStickyStatus
2076          ********************************************************************************
2077          *
2078          * Summary:
2079          *  Manages the Reset and Voltage Detection Status Register 0.
2080          *  This register has the interrupt status for the HVIA, LVID and LVIA.
2081          *  This hardware register clears on read.
2082          *
2083          * Parameters:
2084          *  mask: Bits in the shadow register to clear.
2085          *   Define                  Definition
2086          *   CY_VD_LVID            Persistent status of digital LVI.
2087          *   CY_VD_LVIA            Persistent status of analog LVI.
2088          *   CY_VD_HVIA            Persistent status of analog HVI.
2089          *
2090          * Return:
2091          *  Status.  Same enumerated bit values as used for the mask parameter.
2092          *
2093          *******************************************************************************/
2094          uint8 CyVdStickyStatus(uint8 mask) 
2095          {
2096   1          uint8 status;
2097   1      
2098   1          status = CY_VD_PERSISTENT_STATUS_REG;
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 35  

2099   1          CY_VD_PERSISTENT_STATUS_REG &= ((uint8)(~mask));
2100   1      
2101   1          return(status);
2102   1      }
2103          
2104          
2105          /*******************************************************************************
2106          * Function Name: CyVdRealTimeStatus
2107          ********************************************************************************
2108          *
2109          * Summary:
2110          *  Returns the real time voltage detection status.
2111          *
2112          * Parameters:
2113          *  None
2114          *
2115          * Return:
2116          *  Status:
2117          *   Define                  Definition
2118          *   CY_VD_LVID            Persistent status of digital LVI.
2119          *   CY_VD_LVIA            Persistent status of analog LVI.
2120          *   CY_VD_HVIA            Persistent status of analog HVI.
2121          *
2122          *******************************************************************************/
2123          uint8 CyVdRealTimeStatus(void) 
2124          {
2125   1          uint8 interruptState;
2126   1          uint8 vdFlagsState;
2127   1      
2128   1          interruptState = CyEnterCriticalSection();
2129   1          vdFlagsState = CY_VD_RT_STATUS_REG;
2130   1          CyExitCriticalSection(interruptState);
2131   1      
2132   1          return(vdFlagsState);
2133   1      }
2134          
2135          
2136          /*******************************************************************************
2137          * Function Name: CyDisableInts
2138          ********************************************************************************
2139          *
2140          * Summary:
2141          *  Disables the interrupt enable for each interrupt.
2142          *
2143          * Parameters:
2144          *  None
2145          *
2146          * Return:
2147          *  32 bit mask of previously enabled interrupts.
2148          *
2149          *******************************************************************************/
2150          uint32 CyDisableInts(void) 
2151          {
2152   1          uint32 intState;
2153   1          uint8 interruptState;
2154   1      
2155   1          interruptState = CyEnterCriticalSection();
2156   1      
2157   1          #if(CY_PSOC3)
2158   1      
2159   1              /* Get the current interrupt state. */
2160   1              intState  = ((uint32) CY_GET_REG8(CY_INT_CLR_EN0_PTR));
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 36  

2161   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN1_PTR)) << 8u));
2162   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN2_PTR)) << 16u));
2163   1              intState |= ((uint32) (((uint32) CY_GET_REG8(CY_INT_CLR_EN3_PTR)) << 24u));
2164   1      
2165   1      
2166   1              /* Disable all of the interrupts. */
2167   1              CY_SET_REG8(CY_INT_CLR_EN0_PTR, 0xFFu);
2168   1              CY_SET_REG8(CY_INT_CLR_EN1_PTR, 0xFFu);
2169   1              CY_SET_REG8(CY_INT_CLR_EN2_PTR, 0xFFu);
2170   1              CY_SET_REG8(CY_INT_CLR_EN3_PTR, 0xFFu);
2171   1      
2172   1          #else
              
                      /* Get the current interrupt state. */
                      intState = CY_GET_REG32(CY_INT_CLEAR_PTR);
              
                      /* Disable all of the interrupts. */
                      CY_SET_REG32(CY_INT_CLEAR_PTR, 0xFFFFFFFFu);
              
                  #endif /* (CY_PSOC3) */
2181   1      
2182   1          CyExitCriticalSection(interruptState);
2183   1      
2184   1          return (intState);
2185   1      }
2186          
2187          
2188          /*******************************************************************************
2189          * Function Name: CyEnableInts
2190          ********************************************************************************
2191          *
2192          * Summary:
2193          *  Enables interrupts to a given state.
2194          *
2195          * Parameters:
2196          *  uint32 mask: 32 bit mask of interrupts to enable.
2197          *
2198          * Return:
2199          *  None
2200          *
2201          *******************************************************************************/
2202          void CyEnableInts(uint32 mask) 
2203          {
2204   1      
2205   1          uint8 interruptState;
2206   1      
2207   1          interruptState = CyEnterCriticalSection();
2208   1      
2209   1          #if(CY_PSOC3)
2210   1      
2211   1              /* Set interrupts as enabled. */
2212   1              CY_SET_REG8(CY_INT_SET_EN3_PTR, ((uint8) (mask >> 24u)));
2213   1              CY_SET_REG8(CY_INT_SET_EN2_PTR, ((uint8) (mask >> 16u)));
2214   1              CY_SET_REG8(CY_INT_SET_EN1_PTR, ((uint8) (mask >> 8u )));
2215   1              CY_SET_REG8(CY_INT_SET_EN0_PTR, ((uint8) (mask )));
2216   1      
2217   1          #else
              
                      CY_SET_REG32(CY_INT_ENABLE_PTR, mask);
              
                  #endif /* (CY_PSOC3) */
2222   1      
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 37  

2223   1          CyExitCriticalSection(interruptState);
2224   1      
2225   1      }
2226          
2227          #if(CY_PSOC5)
              
                  /*******************************************************************************
                  * Function Name: CyFlushCache
                  ********************************************************************************
                  * Summary:
                  *  Flushes the PSoC 5/5LP cache by invalidating all entries.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyFlushCache(void)
                  {
                      uint8 interruptState;
              
                      /* Save current global interrupt enable and disable it */
                      interruptState = CyEnterCriticalSection();
              
                      /* Fill instruction prefectch unit to insure data integrity */
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
                      CY_NOP;
              
                      /* All entries in cache are invalidated on next clock cycle. */
                      CY_CACHE_CONTROL_REG |= CY_CACHE_CONTROL_FLUSH;
              
                      /* Once this is executed it's guaranteed the cache has been flushed */
                      (void) CY_CACHE_CONTROL_REG;
              
                      /* Flush the pipeline */
                      CY_SYS_ISB;
              
                      /* Restore global interrupt enable state */
                      CyExitCriticalSection(interruptState);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetSysVector
                  ********************************************************************************
                  * Summary:
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 38  

                  *  Sets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  * Parameters:
                  *  number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEM_MANAGE_IRQN         - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  *  address: Pointer to an interrupt service routine.
                  *
                  * Return:
                  *   The old ISR vector at this location.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetSysVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[number & CY_INT_SYS_NUMBER_MASK] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetSysVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the interrupt vector of the specified system interrupt number. System
                  *  interrupts are present only for the ARM platform. These interrupts are for
                  *  SysTick, PendSV and others.
                  *
                  * Parameters:
                  *  number: System interrupt number:
                  *    CY_INT_NMI_IRQN                - Non Maskable Interrupt
                  *    CY_INT_HARD_FAULT_IRQN         - Hard Fault Interrupt
                  *    CY_INT_MEMORY_MANAGEMENT_IRQN  - Memory Management Interrupt
                  *    CY_INT_BUS_FAULT_IRQN          - Bus Fault Interrupt
                  *    CY_INT_USAGE_FAULT_IRQN        - Usage Fault Interrupt
                  *    CY_INT_SVCALL_IRQN             - SV Call Interrupt
                  *    CY_INT_DEBUG_MONITOR_IRQN      - Debug Monitor Interrupt
                  *    CY_INT_PEND_SV_IRQN            - Pend SV Interrupt
                  *    CY_INT_SYSTICK_IRQN            - System Tick Interrupt
                  *
                  * Return:
                  *   Address of the ISR in the interrupt vector table.
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 39  

                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetSysVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_SYS_NUMBER_MAX);
              
                      return ramVectorTable[number & CY_INT_SYS_NUMBER_MASK];
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *  address: Pointer to an interrupt service routine
                  *
                  * Return:
                  *   Previous interrupt vector value.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntSetVector(uint8 number, cyisraddress address)
                  {
                      cyisraddress oldIsr;
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Save old Interrupt service routine. */
                      oldIsr = ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)];
              
                      /* Set new Interrupt service routine. */
                      ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)] = address;
              
                      return (oldIsr);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetVector
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the interrupt vector of the specified interrupt number.
                  *
                  * Parameters:
                  *  number: Valid range [0-31].  Interrupt number
                  *
                  * Return:
                  *  The address of the ISR in the interrupt vector table.
                  *
                  *******************************************************************************/
                  cyisraddress CyIntGetVector(uint8 number)
                  {
                      cyisraddress *ramVectorTable = *CY_INT_VECT_TABLE;
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 40  

                      return (ramVectorTable[CY_INT_IRQ_BASE + (number & CY_INT_NUMBER_MASK)]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntSetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the Priority of the Interrupt.
                  *
                  * Parameters:
                  *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CyIntSetPriority(uint8 number, uint8 priority)
                  {
                      CYASSERT(priority <= CY_INT_PRIORITY_MAX);
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
                      CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] = (priority & CY_INT_PRIORITY_MASK)<< 5;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetPriority
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets the Priority of the Interrupt.
                  *
                  * Parameters:
                  *  number: The number of the interrupt, 0 - 31.
                  *
                  * Return:
                  *  Priority of the interrupt. 0 - 7, 0 being the highest.
                  *
                  *******************************************************************************/
                  uint8 CyIntGetPriority(uint8 number)
                  {
                      uint8 priority;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
              
                      return (priority);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CyIntGetState
                  ********************************************************************************
                  *
                  * Summary:
                  *   Gets the enable state of the specified interrupt number.
                  *
                  * Parameters:
                  *   number: Valid range [0-31].  Interrupt number.
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 41  

                  *
                  * Return:
                  *   Enable status: 1 if enabled, 0 if disabled
                  *
                  *******************************************************************************/
                  uint8 CyIntGetState(uint8 number)
                  {
                      reg32 * stateReg;
              
                      CYASSERT(number <= CY_INT_NUMBER_MAX);
              
                      /* Get pointer to Interrupt enable register. */
                      stateReg = CY_INT_ENABLE_PTR;
              
                      /* Get state of interrupt. */
                      return (0u != (*stateReg & (((uint32) 1u) << (0x1Fu & number)))) ? ((uint8)(1u)) : ((uint8)(0u));
                  }
              
              
              #else   /* PSoC3 */
2491          
2492          
2493              /*******************************************************************************
2494              * Function Name: CyIntSetVector
2495              ********************************************************************************
2496              *
2497              * Summary:
2498              *  Sets the interrupt vector of the specified interrupt number.
2499              *
2500              * Parameters:
2501              *  number:  Valid range [0-31].  Interrupt number
2502              *  address: Pointer to an interrupt service routine
2503              *
2504              * Return:
2505              *  Previous interrupt vector value.
2506              *
2507              *******************************************************************************/
2508              cyisraddress CyIntSetVector(uint8 number, cyisraddress address) 
2509              {
2510   1              cyisraddress oldIsr;
2511   1      
2512   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2513   1      
2514   1              /* Save old Interrupt service routine. */
2515   1              oldIsr = (cyisraddress) \
2516   1                          CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]);
2517   1      
2518   1              /* Set new Interrupt service routine. */
2519   1              CY_SET_REG16(&CY_INT_VECT_TABLE[number], (uint16) address);
2520   1      
2521   1              return (oldIsr);
2522   1          }
2523          
2524          
2525              /*******************************************************************************
2526              * Function Name: CyIntGetVector
2527              ********************************************************************************
2528              *
2529              * Summary:
2530              *  Gets the interrupt vector of the specified interrupt number.
2531              *
2532              * Parameters:
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 42  

2533              *  number: Valid range [0-31].  Interrupt number
2534              *
2535              * Return:
2536              *  Address of the ISR in the interrupt vector table.
2537              *
2538              *******************************************************************************/
2539              cyisraddress CyIntGetVector(uint8 number) 
2540              {
2541   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2542   1      
2543   1              return ((cyisraddress) \
2544   1                      CY_GET_REG16(&CY_INT_VECT_TABLE[number & CY_INT_NUMBER_MASK]));
2545   1          }
2546          
2547          
2548              /*******************************************************************************
2549              * Function Name: CyIntSetPriority
2550              ********************************************************************************
2551              *
2552              * Summary:
2553              *  Sets the Priority of the Interrupt.
2554              *
2555              * Parameters:
2556              *  priority: Priority of the interrupt. 0 - 7, 0 being the highest.
2557              *  number:   The number of the interrupt, 0 - 31.
2558              *
2559              * Return:
2560              *  None
2561              *
2562              *******************************************************************************/
2563              void CyIntSetPriority(uint8 number, uint8 priority) 
2564              {
2565   1              CYASSERT(priority <= CY_INT_PRIORITY_MAX);
2566   1      
2567   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2568   1      
2569   1              CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] =
2570   1                          (priority & CY_INT_PRIORITY_MASK) << 5;
2571   1          }
2572          
2573          
2574              /*******************************************************************************
2575              * Function Name: CyIntGetPriority
2576              ********************************************************************************
2577              *
2578              * Summary:
2579              *  Gets the Priority of the Interrupt.
2580              *
2581              * Parameters:
2582              *  number: The number of the interrupt, 0 - 31.
2583              *
2584              * Return:
2585              *  Priority of the interrupt. 0 - 7, 0 being the highest.
2586              *
2587              *******************************************************************************/
2588              uint8 CyIntGetPriority(uint8 number) 
2589              {
2590   1              uint8 priority;
2591   1      
2592   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2593   1      
2594   1              priority = CY_INT_PRIORITY_PTR[number & CY_INT_NUMBER_MASK] >> 5;
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 43  

2595   1      
2596   1              return (priority);
2597   1          }
2598          
2599          
2600              /*******************************************************************************
2601              * Function Name: CyIntGetState
2602              ********************************************************************************
2603              *
2604              * Summary:
2605              *   Gets the enable state of the specified interrupt number.
2606              *
2607              * Parameters:
2608              *   number: Valid range [0-31].  Interrupt number.
2609              *
2610              * Return:
2611              *   Enable status: 1 if enabled, 0 if disabled
2612              *
2613              *******************************************************************************/
2614              uint8 CyIntGetState(uint8 number) 
2615              {
2616   1              reg8 * stateReg;
2617   1      
2618   1              CYASSERT(number <= CY_INT_NUMBER_MAX);
2619   1      
2620   1              /* Get pointer to Interrupt enable register. */
2621   1              stateReg = CY_INT_ENABLE_PTR + ((number & CY_INT_NUMBER_MASK) >> 3u);
2622   1      
2623   1              /* Get state of interrupt. */
2624   1              return ((0u != (*stateReg & ((uint8)(1u << (0x07u & number))))) ? ((uint8)(1u)) : ((uint8)(0u)));
2625   1          }
2626          
2627          
2628          #endif  /* (CY_PSOC5) */
2629          
2630          
2631          #if(CYDEV_VARIABLE_VDDA == 1)
              
                  /*******************************************************************************
                  * Function Name: CySetScPumps
                  ********************************************************************************
                  *
                  * Summary:
                  *  If 1 is passed as a parameter:
                  *   - if any of the SC blocks are used - enable pumps for the SC blocks and
                  *     start boost clock.
                  *   - For each enabled SC block set a boost clock index and enable the boost
                  *     clock.
                  *
                  *  If non-1 value is passed as a parameter:
                  *   - If all SC blocks are not used - disable pumps for the SC blocks and
                  *     stop the boost clock.
                  *   - For each enabled SC block clear the boost clock index and disable the  boost
                  *     clock.
                  *
                  *  The global variable CyScPumpEnabled is updated to be equal to passed the
                  *  parameter.
                  *
                  * Parameters:
                  *   uint8 enable: Enable/disable SC pumps and the boost clock for the enabled SC block.
                  *                 1 - Enable
                  *                 0 - Disable
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 44  

                  *
                  * Return:
                  *   None
                  *
                  *******************************************************************************/
                  void CySetScPumps(uint8 enable) 
                  {
                      if(1u == enable)
                      {
                          /* The SC pumps should be enabled */
                          CyScPumpEnabled = 1u;
                          /* Enable pumps if any of SC blocks are used */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAPS_MASK))
                          {
                              CY_LIB_SC_MISC_REG |= CY_LIB_SC_MISC_PUMP_FORCE;
                              CyScBoostClk_Start();
                          }
                          /* Set positive pump for each enabled SC block: set clock index and enable it */
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP0_EN))
                          {
                              CY_LIB_SC0_BST_REG = (CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC0_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP1_EN))
                          {
                              CY_LIB_SC1_BST_REG = (CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC1_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP2_EN))
                          {
                              CY_LIB_SC2_BST_REG = (CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC2_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                          if(0u != (CY_LIB_ACT_CFG9_REG & CY_LIB_ACT_CFG9_SWCAP3_EN))
                          {
                              CY_LIB_SC3_BST_REG = (CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK) | CyScBoostClk__I
             -NDEX;
                              CY_LIB_SC3_BST_REG |= CY_LIB_SC_BST_CLK_EN;
                          }
                      }
                      else
                      {
                          /* The SC pumps should be disabled */
                          CyScPumpEnabled = 0u;
                          /* Disable pumps for all SC blocks and stop boost clock */
                          CY_LIB_SC_MISC_REG &= ((uint8)(~CY_LIB_SC_MISC_PUMP_FORCE));
                          CyScBoostClk_Stop();
                          /* Disable boost clock and clear clock index for each SC block */
                          CY_LIB_SC0_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC0_BST_REG = CY_LIB_SC0_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC1_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC1_BST_REG = CY_LIB_SC1_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC2_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC2_BST_REG = CY_LIB_SC2_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                          CY_LIB_SC3_BST_REG &= ((uint8)(~CY_LIB_SC_BST_CLK_EN));
                          CY_LIB_SC3_BST_REG = CY_LIB_SC3_BST_REG & CY_LIB_SC_BST_CLK_INDEX_MASK;
                      }
                  }
              
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 45  

              #endif  /* (CYDEV_VARIABLE_VDDA == 1) */
2716          
2717          
2718          #if(CY_PSOC5)
                  /*******************************************************************************
                  * Function Name: CySysTickStart
                  ********************************************************************************
                  *
                  * Summary:
                  *  Configures the SysTick timer to generate interrupt every 1 ms by call to the
                  *  CySysTickInit() function and starts it by calling CySysTickEnable() function.
                  *  Refer to the corresponding function description for the details.
              
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStart(void)
                  {
                      if (0u == CySysTickInitVar)
                      {
                          CySysTickInit();
                          CySysTickInitVar = 1u;
                      }
              
                      CySysTickEnable();
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickInit
                  ********************************************************************************
                  *
                  * Summary:
                  *  Initializes the callback addresses with pointers to NULL, associates the
                  *  SysTick system vector with the function that is responsible for calling
                  *  registered callback functions, configures SysTick timer to generate interrupt
                  * every 1 ms.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set.
                  *
                  *  The 1 ms interrupt interval is configured based on the frequency determined
                  *  by PSoC Creator at build time. If System clock frequency is changed in
                  *  runtime, the CyDelayFreq() with the appropriate parameter should be called.
                  *
                  *******************************************************************************/
                  void CySysTickInit(void)
                  {
                      uint32 i;
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 46  

              
                      for (i = 0u; i<CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                      {
                          CySysTickCallbacks[i] = (void *) 0;
                      }
              
                      (void) CyIntSetSysVector(CY_INT_SYSTICK_IRQN, &CySysTickServiceCallbacks);
                      CySysTickSetClockSource(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK);
                      CySysTickSetReload(cydelay_freq_hz/1000u);
                      CySysTickClear();
                      CyIntEnable(CY_INT_SYSTICK_IRQN);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickEnable
                  ********************************************************************************
                  *
                  * Summary:
                  *  Enables the SysTick timer and its interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnable(void)
                  {
                      CySysTickEnableInterrupt();
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickStop
                  ********************************************************************************
                  *
                  * Summary:
                  *  Stops the system timer (SysTick).
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickStop(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE));
                  }
              
              
                  /*******************************************************************************
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 47  

                  * Function Name: CySysTickEnableInterrupt
                  ********************************************************************************
                  *
                  * Summary:
                  *  Enables the SysTick interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickEnableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG |= CY_SYS_SYST_CSR_ENABLE_INT;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickDisableInterrupt
                  ********************************************************************************
                  *
                  * Summary:
                  *  Disables the SysTick interrupt.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  * Side Effects:
                  *  Clears SysTick count flag if it was set
                  *
                  *******************************************************************************/
                  void CySysTickDisableInterrupt(void)
                  {
                      CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_ENABLE_INT));
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetReload
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets value the counter is set to on startup and after it reaches zero. This
                  *  function do not change or reset current sysTick counter value, so it should
                  *  be cleared using CySysTickClear() API.
                  *
                  * Parameters:
                  *  value: Valid range [0x0-0x00FFFFFF]. Counter reset value.
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CySysTickSetReload(uint32 value)
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 48  

                  {
                      CY_SYS_SYST_RVR_REG = (value & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetReload
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets value the counter is set to on startup and after it reaches zero.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Counter reset value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetReload(void)
                  {
                      return(CY_SYS_SYST_RVR_REG & CY_SYS_SYST_RVR_CNT_MASK);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetValue
                  ********************************************************************************
                  *
                  * Summary:
                  *  Gets current SysTick counter value.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Current SysTick counter value
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetValue(void)
                  {
                      return(CY_SYS_SYST_RVR_REG & CY_SYS_SYST_CVR_REG);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickSetClockSource
                  ********************************************************************************
                  *
                  * Summary:
                  *  Sets the clock source for the SysTick counter.
                  *
                  * Parameters:
                  *  clockSource: Clock source for SysTick counter
                  *         Define                     Clock Source
                  *   CY_SYS_SYST_CSR_CLK_SRC_SYSCLK     SysTick is clocked by CPU clock.
                  *   CY_SYS_SYST_CSR_CLK_SRC_LFCLK      SysTick is clocked by the low frequency
                  *                              clock (ILO 100 KHz for PSoC 5LP, LFCLK for PSoC 4).
                  *
                  * Return:
                  *  None
                  *
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 49  

                  * Side Effects:
                  *  Clears SysTick count flag if it was set. If clock source is not ready this
                  *  function call will have no effect. After changing clock source to the low frequency
                  *  clock the counter and reload register values will remain unchanged so time to
                  *  the interrupt will be significantly bigger and vice versa.
                  *
                  *******************************************************************************/
                  void CySysTickSetClockSource(uint32 clockSource)
                  {
                      if (clockSource == CY_SYS_SYST_CSR_CLK_SRC_SYSCLK)
                      {
                          CY_SYS_SYST_CSR_REG |= (uint32)(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_CLK_SOURCE_S
             -HIFT);
                      }
                      else
                      {
                          CY_SYS_SYST_CSR_REG &= ((uint32) ~(CY_SYS_SYST_CSR_CLK_SRC_SYSCLK << CY_SYS_SYST_CSR_CLK_SOURC
             -E_SHIFT));
                      }
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCountFlag
                  ********************************************************************************
                  *
                  * Summary:
                  *  The count flag is set once SysTick counter reaches zero.
                  *   The flag cleared on read.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  Returns non-zero value if counter is set, otherwise zero is returned.
                  *
                  *******************************************************************************/
                  uint32 CySysTickGetCountFlag(void)
                  {
                      return ((CY_SYS_SYST_CSR_REG>>CY_SYS_SYST_CSR_COUNTFLAG_SHIFT) & 0x01u);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickClear
                  ********************************************************************************
                  *
                  * Summary:
                  *  Clears the SysTick counter for well-defined startup.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  void CySysTickClear(void)
                  {
                      CY_SYS_SYST_CVR_REG = 0u;
                  }
              
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 50  

              
                  /*******************************************************************************
                  * Function Name: CySysTickSetCallback
                  ********************************************************************************
                  *
                  * Summary:
                  *  The function set the pointers to the functions that will be called on
                  *  SysTick interrupt.
                  *
                  * Parameters:
                  *  number:  The number of callback function address to be set.
                  *           The valid range is from 0 to 4.
                  *  CallbackFunction: Function address.
                  *
                  * Return:
                  *  Returns the address of the previous callback function.
                  *  The NULL is returned if the specified address in not set.
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickSetCallback(uint32 number, cySysTickCallback function)
                  {
                      cySysTickCallback retVal;
              
                      retVal = CySysTickCallbacks[number];
                      CySysTickCallbacks[number] = function;
                      return (retVal);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickGetCallback
                  ********************************************************************************
                  *
                  * Summary:
                  *  The function get the specified callback pointer.
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
                  *******************************************************************************/
                  cySysTickCallback CySysTickGetCallback(uint32 number)
                  {
                      return ((cySysTickCallback) CySysTickCallbacks[number]);
                  }
              
              
                  /*******************************************************************************
                  * Function Name: CySysTickServiceCallbacks
                  ********************************************************************************
                  *
                  * Summary:
                  *  System Tick timer interrupt routine
                  *
                  * Parameters:
                  *  None
                  *
                  * Return:
                  *  None
                  *
C51 COMPILER V9.51   CYLIB                                                                 09/27/2016 06:28:45 PAGE 51  

                  *******************************************************************************/
                  static void CySysTickServiceCallbacks(void)
                  {
                      uint32 i;
              
                      /* Verify that tick timer flag was set */
                      if (1u == CySysTickGetCountFlag())
                      {
                          for (i=0u; i < CY_SYS_SYST_NUM_OF_CALLBACKS; i++)
                          {
                              if (CySysTickCallbacks[i] != (void *) 0)
                              {
                                  (void)(CySysTickCallbacks[i])();
                              }
                          }
                      }
                  }
              #endif /* (CY_PSOC5) */
3103          
3104          
3105          /* [] END OF FILE */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   4441    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =     96    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
